<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ConcurrentHashMap底层源码分析</title>
    <url>/2020/02/28/ConcurrentHashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>ConcurrentHashMap是Java中的一个<strong>线程安全且高效的HashMap实现</strong>。平时涉及高并发如果要用map结构，那第一时间想到的就是它。<br>为什么它是线程安全的，我抽时间去看了下源码，关键在   <strong>synchronized</strong> 方法。这篇笔记写下我对源码的一些分析和理解，方便加深映像</p>
<a id="more"></a>

<p><strong>put 方法 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">//如果是第一次,则先创建哈希表</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//如果当前数据要放的位置上面没有数据,</span></span><br><span class="line">          <span class="comment">//则通过 cas 比较交换,将原始的 null 替换为最新的值</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">                <span class="comment">//如果当前要插入的数组位置有数据的,</span></span><br><span class="line">                <span class="comment">//则锁定当前表头,注意：是没有锁定当前要插入的对应的key 的具体数据,</span></span><br><span class="line">                <span class="comment">//因为到现在位置还不知道这个位置后有没有我们要放的数据,</span></span><br><span class="line">                <span class="comment">//有可能有,有可能没有,如果锁的是存在的那个节点,</span></span><br><span class="line">                <span class="comment">//得先进去遍历,但是有可能没有,那么可能到最后都没有加锁,就是去了安全性的意义</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap底层源码分析</title>
    <url>/2020/02/27/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><ol>
<li>源码中属性介绍</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表数组的默认长度 16</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表数组的最大长度,2的30次方的原因是,int 最大值是 2的31次方减 1,所以只能是 30 次方</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//默认的加载因子,加载因子指的是 hashmap 中数据个数超过数组长度*当前加载因子的时候会触发扩容</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//当单个位置的数据链表长度超过 8 的时候会将该链表转换为红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当当前位置的红黑树内容长度小于 6 的时候会重新变回链表</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当某个位置的链表在转换为红黑树的时候,如果此时数组长度小于 64 会先进行扩容</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="2-put-方法介绍"><a href="#2-put-方法介绍" class="headerlink" title="2 put 方法介绍"></a>2 put 方法介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//声明了一个局部变量 tab,局部变量 Node 类型的数据 p,int 类型 n,i</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">//首先将当前 hashmap 中的 table(哈希表)赋值给当前的局部变量 tab,然后判断tab 是不是空或者长度是不是 0,实际上就是判断当前 hashmap 中的哈希表是不是空或者长度等于 0</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//如果是空的或者长度等于0,代表现在还没哈希表,所以需要创建新的哈希表,默认就是创建了一个长度为 16 的哈希表</span></span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">//将当前哈希表中与要插入的数据位置对应的数据取出来,(n - 1) &amp; hash])就是找当前要插入的数据应该在哈希表中的位置,如果没找到,代表哈希表中当前的位置是空的,否则就代表找到数据了, 并赋值给变量 p</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//创建一个新的数据,这个数据没有下一条,并将数据放到当前这个位置</span></span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="comment">//代表要插入的数据所在的位置是有内容的</span></span><br><span class="line">      <span class="comment">//声明了一个节点 e, 一个 key k</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp; <span class="comment">//如果当前位置上的那个数据的 hash 和我们要插入的 hash 是一样,代表没有放错位置</span></span><br><span class="line">          <span class="comment">//如果当前这个数据的 key 和我们要放的 key 是一样的,实际操作应该是就替换值</span></span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="comment">//将当前的节点赋值给局部变量 e</span></span><br><span class="line">              e = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果当前节点的 key 和要插入的 key 不一样,然后要判断当前节点是不是一个红黑色类型的节点</span></span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);<span class="comment">//如果是就创建一个新的树节点,并把数据放进去</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果不是树节点,代表当前是一个链表,那么就遍历链表</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//如果当前节点的下一个是空的,就代表没有后面的数据了</span></span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//创建一个新的节点数据并放到当前遍历的节点的后面</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 重新计算当前链表的长度是不是超出了限制</span></span><br><span class="line">                          treeifyBin(tab, hash);<span class="comment">//超出了之后就将当前链表转换为树,注意转换树的时候,如果当前数组的长度小于MIN_TREEIFY_CAPACITY(默认 64),会触发扩容,我个人感觉可能是因为觉得一个节点下面的数据都超过8 了,说明 hash寻址重复的厉害(比如数组长度为 16 ,hash 值刚好是 0或者 16 的倍数,导致都去同一个位置),需要重新扩容重新 hash</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果当前遍历到的数据和要插入的数据的 key 是一样,和上面之前的一样,赋值给变量 e,下面替换内容</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//如果当前的节点不等于空,</span></span><br><span class="line">              V oldValue = e.value;<span class="comment">//将当前节点的值赋值给 oldvalue</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value; <span class="comment">//将当前要插入的 value 替换当前的节点里面值</span></span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++modCount;<span class="comment">//增加长度</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();<span class="comment">//如果当前的 hash表的长度已经超过了当前 hash 需要扩容的长度, 重新扩容,条件是 haspmap 中存放的数据超过了临界值(经过测试),而不是数组中被使用的下标</span></span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-扩容方法"><a href="#3-扩容方法" class="headerlink" title="3 扩容方法"></a>3 扩容方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//haspmap 触发扩容的条件有两个,一个是当存放的数据超过临界值的时候会触发扩容,</span></span><br><span class="line"><span class="comment">//另外一个是当需要转成红黑树的时候,如果当前数组的长度小于 64,会触发扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//声明了一个 oldtab ,并且把当前(扩容前) hashmap里面的哈希表赋值过来,如果是第一次放数据,此时这两个其实都是空</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//获取当前(扩容前)哈希表的长度,如果是第一次的话,就是 0,否则就是扩容之前的哈希表的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//当前(扩容前)哈希表需要扩容时候的长度,其实这值就是哈希表的长度*加载因子的长度,如果是第一次放数据,就是 0</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">//新的长度和新的扩容长度</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//如果是第一次的时候,这个长度是 0,所以不符合当前判断,如果大于 0 代表是原先的老哈希表长度已经超出限制了</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//看看最新的长度是不是大于等于hashmap 对数组长度的最大限制</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;<span class="comment">//设置为默认的最大长度</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; </span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//如果没有超出长度限制,新的数组长度等于老的数组长度*2(向左移动 1 位)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//如果当前的扩容长度大于 0,代表已经有哈希表</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//代表还没有哈希表,实际上就是第一次向 map 中放数据</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新的哈希表长度为当前map 的默认值</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">//新的扩容长度为默认长度*默认的加载因子,这里算它的原因是为了不在后面放数据的时候每次都重新计算,因为每次都要算是不是应该扩容,如果不找变量接收,每次都要做数学运算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新的长度还是 0,则继续计算</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;<span class="comment">//当前 hashma的扩容长度等于最新计算出来的扩容长度</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//根据最新的长度创建对应长度的哈希表,如果是首次创建,默认就是 16</span></span><br><span class="line">        table = newTab;<span class="comment">//将当前 hashmap 中的哈希表赋值为最新刚刚创建的哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//如果原老的哈希表有数据,需要将老的数据放到新的哈希表,如果是首次创建就不执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">//遍历老的数组</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">//取出当前遍历的位置上的第一个节点</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果当前节点没有后面的数据</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//新的数组的最新的节点上的数据直接就是这个数据</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是不是树节点,如果是 就重新对树进行分割,然后放到新的位置</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// 创建两个链表,主要是因为基本上扩容的时候,部分数据会在原始位置,另外一部分数据会去向后便宜老数组的长度,比如原先是数组长度是 16,原先在 1 位置上面的数据,扩容到 32 后要么就还在 1,要么就应该去17,也就是向后移动原始长度(或者是扩容增加的长度)</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next; <span class="comment">//首先将当前的下一个数据赋值给 e</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//符合应该在原始位置条件的创建一条链表</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">//如果没有数据</span></span><br><span class="line">                                    loHead = e;<span class="comment">//当前节点就是一个头</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;<span class="comment">//否则当前的尾节点下一条数据就是 e</span></span><br><span class="line">                                loTail = e;<span class="comment">//e 就成为了尾结点</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;<span class="comment">//代表不符合原始位置的条件,就创建另外一个链表,来存放另外一部分数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)<span class="comment">//如果没有数据</span></span><br><span class="line">                                    hiHead = e;<span class="comment">//当前节点就是一个头</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;<span class="comment">//否则当前的尾节点下一条数据就是 e</span></span><br><span class="line">                                hiTail = e;<span class="comment">//e 就成为了尾结点</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//如果当前位置下一个数据不等于空,继续向下找</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; </span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;<span class="comment">//遍历完成后,当前位置的数据为上面构建的应该在当前原始位置的链表数据</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;<span class="comment">//将另外一部分数据直接放到后面的位置,位置为原始位置加上偏移量(因为扩容就是翻倍长度,所以偏移量就是原始的长度或者说是扩容增加的长度)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab; <span class="comment">//返回最新创建的那个哈希表</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-链表转红黑树"><a href="#4-链表转红黑树" class="headerlink" title="4 链表转红黑树"></a>4 链表转红黑树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">   * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果当前哈希表是空的或者是哈希表的数组长度小于 64,则触发扩容,这也是 hashmap 扩容的第二个条件和方式</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap简述</title>
    <url>/2020/03/17/HashMap%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>底层是基于哈希表实现的键值对存储，继承AbstractMap并实现了Map接口，HashMap基于hashing原理，通过put() 和 get()方法存储和获取对象。<br>当我们将键值对传递给put()方法时，它调用键值对象hashCode()方法来计算hashCode，然后找到bucket（桶）位置来存储值对象。当获取对象时，通过健对象的equals()方法找到正确的键值对，然后返回值对象。</p>
<p>HashMap 使用LinkedList来解决碰撞问题。当发生碰撞，对象将会存储在LinkedList的下一个节点中。</p>
<p><strong>简单介绍一下hashcode()？</strong><br>hashcode就是通过hash函数计算得来的值，返回的是int类型</p>
  <a id="more"></a>

<p><strong>当两个不同键对象的hashCode相同时会发生什么？</strong></p>
<p>他们会存储在同一个bucket（散列桶）位置的LinkedList中。键对象的equals()方法用来找到键值对。</p>
<p><strong>nitialCapacity</strong>： 初始容量。指的是HashMap 集合初始化的时候自身的容量。可以在构造方法中指定。如果不指定的话，总容量默认值是16 .需要注意的是初始容量必须是2的幂次方</p>
<p><strong>size</strong> ： 当前HashMap中已经存储着的键值对数量 </p>
<p><strong>loadFactor</strong>: 加载因子。所谓的加载因子就是HashMap(当前的容量/总容量)达到一定值的时候，HashMap 会实施扩容。加载因子也可以通过构造方法中指定，默认的值是 0.75  .</p>
<p><strong>threshold</strong> ： 扩容阈值，即 扩容阈值 = HashMap 总容量  *  加载因子。 当前HashMap的容量大于或等于扩容阈值的时候就回去执行扩容。扩容的容量为当前HashMap 总容量的两倍。比如，当前 HashMap 的总容量 为 16  ，那么扩容之后为32.</p>
<p>举个例子：<br>          假设有一个HashMap 集合初始容量为<strong>16  ，</strong>那么扩容的阈值就是 0.75 * 16 = 12 . 也就是说，在你打算存入第13个值的时候，HashMap 会先执行扩容。</p>
<p><strong>Java JDK 1.7之前</strong>  HashMap 的实现方式是 Entry 数组+ 链表的形式。<strong>java 1.7 会在链表头插入（头插法）</strong>，使用头插法会造成一个问题，是当它在resize的时候，也就是说hashmap的扩容的过程，它的里面有一个 resize（）方法，然后它又调用了一个   transfer（） 方法，把里面的Entry进行一个rehash，在这个过程中可能会造成一个链表的循环（环形链表的问题），就有可能我在进行下一个get（）的时候造成一个死循环，因为它是没有加锁的，在多个线程并发的情况下，它不能对它的数据保证安全，就是我push（）进去的值，取出来还是我push（）进去的一个值，这是一个非常不安全的情况。<br><strong>Java JDK1.8之后</strong> <strong>1.8 之后它会在链表尾插入（尾插法）</strong>还有一个对它的一个非常大的变化就是 数据结构发生了改变，Entry节点 被 Node节点给替代了 它是一个 <strong>数组+链表+红黑树</strong>的一个数据结构。 <strong>1.8之后对 put（k,v）的过程也做了一个优化</strong>，首先对key的hashcode（）做hash 算法计算，然后是return 到 putval（）方法中进行的，它首先先判断tab是否为null，为null就创建，再一个计算index，并对null做处理，然后判断节点key是否存在，如果不为null,也就是节点key存在，直接覆盖value，否则判断该链为红黑树，然后判断链表长度是否大于8，进行一个红黑树转换的处理，最后一个步骤是判断是否超过最大容量也就是扩容。</p>
<p><strong>JDK1.8 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">7</span>                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>         n = (tab = resize()).length;</span><br><span class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理</span></span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">20</span>             e = p;</span><br><span class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st </span></span><br><span class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</span><br><span class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span>                 &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">35</span>                            <span class="keyword">break</span>;</span><br><span class="line"><span class="number">36</span>                 p = e;</span><br><span class="line"><span class="number">37</span>             &#125;</span><br><span class="line"><span class="number">38</span>         &#125;</span><br><span class="line"><span class="number">39</span>        </span><br><span class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">41</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">43</span>                 e.value = value;</span><br><span class="line"><span class="number">44</span>             afterNodeAccess(e);</span><br><span class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">46</span>         &#125;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"><span class="number">48</span>     ++modCount;</span><br><span class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">51</span>         resize();</span><br><span class="line"><span class="number">52</span>     afterNodeInsertion(evict);</span><br><span class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">54</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK 1.7 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123; <span class="comment">//空表table的话，根据size的阈值填充</span></span><br><span class="line"><span class="number">3</span>       inflateTable(threshold);</span><br><span class="line"><span class="number">4</span>    &#125;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">6</span>        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"><span class="number">7</span>    <span class="keyword">int</span> hash = hash(key);<span class="comment">//成hash，得到索引Index的映射</span></span><br><span class="line"><span class="number">8</span>    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"><span class="number">9</span>    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//遍历当前索引的冲突链，找是否存在对应的key</span></span><br><span class="line"><span class="number">10</span>       Object k;</span><br><span class="line"><span class="number">11</span>        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<span class="comment">//如果存在对应的key， 则替换oldValue并返回oldValue</span></span><br><span class="line"><span class="number">12</span>            V oldValue = e.value;</span><br><span class="line"><span class="number">13</span>            e.value = value;</span><br><span class="line"><span class="number">14</span>            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">15</span>            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">16</span>        &#125;</span><br><span class="line"><span class="number">17</span>    &#125;</span><br><span class="line"><span class="number">18</span>    <span class="comment">//冲突链中不存在新写入的Entry的key</span></span><br><span class="line"><span class="number">19</span>    modCount++;</span><br><span class="line"><span class="number">20</span>    addEntry(hash, key, value, i);</span><br><span class="line"><span class="number">21</span>    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是Hash碰撞？</strong></p>
<p>所谓哈希碰撞，就是不同节点值（key-value键值对）的key值算出相同的下标值，就是有可能两个不同的原始值在经过hash算法运算后得到同样的结果，这样就是哈希碰撞</p>
<p><strong>如何解决Hash碰撞的？</strong></p>
<p>为解决哈希碰撞，hashmap采用链地址法解决哈希冲突，也就是采用链表解决哈希冲突，<br>但只单用链表解决哈希冲突的话，链表太长会导致操作hashmap的效率值下降得太多，<br>所以在jdk1.8之后，又引入了红黑树来解决哈希冲突，环形链表问题。</p>
<p><strong>有几种方法？</strong></p>
<p><strong>开放定址法</strong>：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。<br><strong>链地址法</strong>：链地址法其实就是HashMap中用的策略<br>HashMap 使用LinkedList来解决碰撞问题。当发生碰撞，对象将会存储在LinkedList的下一个节点中。）<br>原理是在HashMap中同样哈希值的位置以一串链表存储起来数据，把多个原始值不同而哈希结果相同的数据以链表存储起来。</p>
<p><strong>红黑怎么解决了冲突？ 为什么超过8就转红黑树？</strong></p>
<p><strong>通过自旋</strong></p>
<p>首先呢，你要清楚hashmap其实就是一个数组（entry类型的数组）。<br>理想的哈希表，是尽可能让节点分散到数组的各个下标位置上，而又不重复（没有哈希冲突）。<br>这样呢，才是最理想的hashmap，时间复杂度是O（1）。<br>但是呢，没有一个哈希算法可以避免哈希冲突，冲突再所难免，所以有冲突呢，就得想办法解决。<br>而链表跟红黑树其实只是解决哈希冲突的一个方式而已</p>
<p>因为只单单链表解决哈希冲突的话，当长度超过8时，效率明显不及用红黑树解决哈希冲突</p>
<p>8就是一个链表跟红黑树解决哈希冲突效率对比的临界点</p>
<p><strong>当key相同时会发生什么 key不同呢？</strong></p>
<p>不会有相同的key，其hashCode一定一样，那么put时回去同一桶链表中寻找，而在源码中put的时候<br>如果key和hashCode都与之前存在的节点一样，那么会用新的value覆盖旧的value,并且put方法返回新value的值。</p>
<p><strong>hashmap是线程安全的吗？还有什么线程安全map（类）</strong></p>
<p>因为 hashmap 的 key可以为null值，当发生并发问题时，会出现两个问题：  1）、链表可能会形成环形  2）、发生数据覆盖问题    当一个线程进来的时候，开始判断索引值，    如果索引值为空，当它开始new对象时，代码还没来得及执行，    第二个线程进来，会直接判断为null，会把之前的数据给覆盖掉，发生数据覆盖问题</p>
<p><strong>线程安全map</strong>:  HashTable  SynchronizedMap <strong>ConcurrentHashMap - 推荐</strong>（并发高）</p>
<p><strong>为什么同样是线程安全的不用HashTable 而使用 ConcurrentHashMap ？</strong></p>
<p>因为它的并发度是更高的，普通的 HashTable 保证线程安全的策略是直接对里面的方法进行一个 Synchronized就是加了一个同步锁，而ConcurrentHashMap 的数据结构在1.8之后同样的是 数组+链表+红黑树 它在执行Synchronized上锁的一个过程它只锁住我目前获取到的那个Entry 所在的那个节点的一个值，而且它上锁是使用了  CAS + Synchronized,再加上JDK 1.6之后对Synchronized的一个优化锁升级的过程，它的执行效率，并发是更高的。</p>
<p><strong>PS</strong>:上面这段话如果不理解的话，别着急，我下面还写了一段关于线程安全的HashMap的描述，或者可以看看我之前写的两篇源码分析的文章</p>
<p><strong>什么是锁升级？锁升级的一个过程是什么？</strong></p>
<p>最开始的时候它是一个无锁的状态，当一个线程上来它会去先判断一下是否上了锁，然后再升级，这个锁是支持偏向锁的，就是当前我获取到的锁资源的这个线程，我会优先让他再去获取到这个锁，如果它没有获取到这个锁，就升级成一个轻量级的，一个CAS的锁就是一个乐观锁，乐观锁的时候它是一个比较有交换的过程，如果这个CAS连续没有设置成功的话，它会进行一个自旋，然后自旋到一定的次数之后会升级成一个Synchronized一个重量级的锁，这样的话就保证了它的一个性能的问题</p>
<p><strong>Hashmap是线程安全的吗？如何将它变为线程安全的？</strong></p>
<p><strong>Hashmap</strong>对应的线程安全类有 <strong>Hashtable</strong>、有<strong>ConcurrentHashmap</strong>，也可以通过<strong>Collections</strong>工具类 通过  Collections.Synchronized  将Hashmap包装成线程安全版的map。如果要在三个做出选择，还是建议使用ConcurrentHashMap，因为ConcurrentHashMap的锁粒度要更小，效率要更高。<br>虽然这三者都有通过Synchronized同步锁实现的线程安全。<br>但是这其中，Hashtable的效率跟通过Collections工具类包装的map的效率基本无异，这两者的锁粒度一样，差别只是Hashtable锁的是对象本身，而通过Collections工具类包装的map锁的是同一个Object对象，进入方法后就是一段加了Synchronized同步锁的代码段。两者锁粒度是一样的，效率实际也都没多大区别。<br>而ConcurrentHashMap在JDK1.8版本的时，它加锁的机制是怎样的？它是先根据待插入的节点对象的key值算出节点对象该该放在数组（ConcurrentHashmap底层就是数组）的哪个下标位置上，在看看这个下标位置是否为空，为空则通过CAS机制（乐观锁）来插入节点对象。而如果下标位置不为空，那么ConcurrentHashMap会以Synchronized同步锁来加锁，加锁的对象是数组下标位置上的头节点对象，这样呢，<strong>锁的粒度就小很多，出现并发的概率也会小很多</strong>，自然效率要比前两者高很多。<br>就是说Hashtable及Collections包装的map加锁是锁整一段数组，而ConcurrentHashmap会先在下标位置空的时候通过CAS机制（乐观锁）插入节点数据，此种方式其实是没加锁，而当下标位置不为空时，就是这个下标位置是有数据的，它才会加锁到具体的下标的一个位置。</p>
<p><strong>哈希表  数组  链表的区别。</strong></p>
<p>程序中，存放指定的数据最常用的数据结构有两种：数组和链表。</p>
<p><strong>数组和链表的区别：</strong></p>
<p>1，数组是将元素在内存中连续存放（顺序存储）。<br>   链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。</p>
<p>2，数组必须事先定义固定的长度，不能适应数据动态的增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；<br>   链表动态地进行存储分配，可以适应数据变化动态地增减。</p>
<p>3，（静态）数组从栈中分配空间，对于程序方便快速，但是自由度小；<br>    链表从堆中分配空间，自由度大但是申请管理比较麻烦。</p>
<p> <strong>数组和链表在存储数据方面到底谁好？根据数组和链表的特性，分两种情况讨论：</strong></p>
<p>1，当进行数据查询时，数组可以直接通过下标迅速访问数组中的元素。<br>   而链表则需要从第一个元素开始一直找到需要的元素位置，显然，数组的查询效率会比链表的高。</p>
<p>2，当进行增加或删除元素时，在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，<br>然后将要增加的元素放在其中。同样，如果想删除一个元素，需要移动大量去填掉被移动的元素，<br>而链表只需改动元素中的指针即可实现增加或删除元素。</p>
<p><strong>那么哈希表，是既能具备数组的快速查询的优点，又能融合链表方便快捷的增加删除元素的优势。</strong></p>
<p>所谓的hash,简单的说就是散列，即将输入的数据通过hash函数得到一个key值，输入的数据存储到数组中下标的key值的数组单元中去。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习（一）</title>
    <url>/2020/03/30/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>说到Nginx，最熟悉和使用频繁的两个功能就是用它负载均衡和反向代理。但是Nginx的强大可不仅仅只有这两个功能。这篇笔记结合最近复习Ngxin的一些记录和总结，温故知新，循序渐进。</p>
<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p>Nginx 是由俄罗斯人 Igor Sysoev 设计开发的，开发工作从2002 年开始，第一次公开发布在 2004 年 10 月 4 日。官方网站为：<a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a> 。它是一款免费开源的高性能 HTTP 代理服务器及反向代理服务器（Reverse Proxy）产品，同时它还可以提供 IMAP/POP3 邮件代理服务等功能。它高并发性能很好，官方测试能够支撑 5 万的并发量；运行时内存和 CPU 占用率低，配置简单，容易上手，而且运行非常稳定。</p>
<h2 id="Nginx常用功能"><a href="#Nginx常用功能" class="headerlink" title="Nginx常用功能"></a>Nginx常用功能</h2><p>官方文档功能介绍：<a href="http://nginx.org/en/" target="_blank" rel="noopener">http://nginx.org/en/</a></p>
<a id="more"></a>

<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>这是 Nginx 服务器作为 WEB 服务器的主要功能之一，客户端向服务器发送请求时，会首先经过 Nginx 服务器，由服务器将请求分发到相应的 WEB 服务器。<strong>正向代理是代理客户端，而反向代理则是代理服务器</strong>，Nginx 在提供反向代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置相当灵活，而且在配置后端转发请求时，完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的连接、请求等。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡做为Nginx最常用的功能之一，一方面是<strong>将单一的重负载分担到多个网络节点上做并行处理</strong>，每个节点处理结束后将结果汇总返回给用户，这样可以大幅度提高网络系统的处理能力；另一方面<strong>将大量的前端并发请求或数据流量分担到多个后端网络节点分别处理</strong>，这样可以有效减少前端用户等待相应的时间。而 Nginx 负载均衡都是属于后一方面，主要是对大量前端访问或流量进行分流，已保证前端用户访问效率，并可以减少后端服务器处理压力。</p>
<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>在很多优秀的网站中，Nginx 可以作为<strong>前置缓存服务器</strong>，它被用于缓存前端请求，从而提高 Web服务器的性能。Nginx 会对用户<strong>已经访问过的内容在服务器本地建立副本</strong>，这样在一段时间内再次访问该数据，就不需要通过 Nginx 服务器向后端发出请求。减轻网络拥堵，减小数据传输延时，提高用户访问速度。</p>
<h2 id="安装并使用Nginx"><a href="#安装并使用Nginx" class="headerlink" title="安装并使用Nginx"></a>安装并使用Nginx</h2><p>官方下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p>
<img src="/2020/03/30/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/01.jpg">

<h3 id="Windows环境下"><a href="#Windows环境下" class="headerlink" title="Windows环境下"></a>Windows环境下</h3><p>开发版本主要用于 Nginx 软件项目的研发，稳定版本说明可以作为 Web 服务器投入商业应用。这里我们选择当前稳定版本：<strong>nginx-1.14.0</strong></p>
<p>下载之后将压缩文件解压到指定文件夹</p>
<img src="/2020/03/30/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/02.jpg">

<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>1、conf 目录：存放 Nginx 的主要配置文件，很多功能实现都是通过配置该目录下的 nginx.conf 文件，后面我们会详细介绍。</p>
<p>2、docs 目录：存放 Nginx 服务器的主要文档资料，包括 Nginx 服务器的 LICENSE、OpenSSL 的 LICENSE 、PCRE 的 LICENSE 以及 zlib 的 LICENSE ，还包括本版本的 Nginx服务器升级的版本变更说明，以及 README 文档。</p>
<p>3、html 目录：存放了两个后缀名为 .html 的静态网页文件，这两个文件与 Nginx 服务器的运行相关。</p>
<p>4、logs 目录：存放 Nginx 服务器运行的日志文件。</p>
<p>5、nginx.exe：启动 Nginx 服务器的exe文件，如果 conf 目录下的 nginx.conf 文件配置正确的话，通过该文件即可启动 Nginx 服务器。</p>
<h4 id="简单运行Nginx"><a href="#简单运行Nginx" class="headerlink" title="简单运行Nginx"></a>简单运行Nginx</h4><p>Win+R 输入cmd启用DOS 进入到解压之后的目录 输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx.exe -s start</span><br></pre></td></tr></table></figure>

<p>出现一闪而过的画面，则启动成功。然后在浏览器中输入 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 或者 <a href="http://localhost:80" target="_blank" rel="noopener">http://localhost:80</a> 出现如下界面即启动成功。<img src="/2020/03/30/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/03.jpg"></p>
<p>页面渲染的内容其实就是上面解压目录中 html 目录下的 index.html 文件。</p>
<p>关闭Nginx DOS命令控制台输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx.exe -s stop</span><br></pre></td></tr></table></figure>



<h3 id="Linux环境下"><a href="#Linux环境下" class="headerlink" title="Linux环境下"></a>Linux环境下</h3><h4 id="yum-安装环境"><a href="#yum-安装环境" class="headerlink" title="yum 安装环境"></a>yum 安装环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 yum install gcc-c++</span><br><span class="line">2 yum install -y pcre pcre-devel</span><br><span class="line">3 yum install -y zlib zlib-devel</span><br><span class="line">4 yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>

<p>对于 gcc，因为安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境的话，需要安装gcc。</p>
<p>对于 pcre，prce(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p>
<p>对于 zlib，zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p>
<p>对于 openssl，OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</p>
<p>下载的 nginx-1.14.0.tar.gz 文件通过 Xftp 复制到 Linux 系统自己准备的文件夹中，然后解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure>

<p>接着进入到解压之后的目录，进行编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">2 make</span><br><span class="line">3 make install</span><br></pre></td></tr></table></figure>

<p>注意：指定 /usr/local/nginx 为nginx 服务安装的目录。</p>
<p><strong>启动nginx</strong><br>　　进入到 /usr/local/nginx 目录，文件目录显示如下<img src="/2020/03/30/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/04.jpg"></p>
<p>进入到 sbin 目录，通过如下命令启动 nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>也可以配置环境命令，这样在任意目录都能启动 nginx。Linux 没有消息就好消息，不提示任何信息说明启动成功。也可以用 端口查看命令，查看 nginx 是否有服务正在运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

<p>然后我们在浏览器输入Linux系统的IP地址，出现windows安装成功的界面即可。</p>
<img src="/2020/03/30/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/03.jpg">

<p>Linux 中关闭Nginx可以用两种方式</p>
<p>方式一：快速停止（Linux先是找到nginx进程id然后再强制kill 杀掉进程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">2 .&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure>

<p>方式二：平缓停止（允许 nginx 服务将当前正在处理的网络请求处理完成，但不在接收新的请求，之后关闭连接，停止工作。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">2 .&#x2F;nginx -s quit</span><br></pre></td></tr></table></figure>

<p><strong>重启Nginx</strong></p>
<p>方式一：先停止再启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 .&#x2F;nginx -s quit</span><br><span class="line">2 .&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>方式二：重新加载配置文件<br>通常我们使用nginx修改最多的便是其配置文件 nginx.conf。修改之后想要让配置文件生效而不用重启 nginx，便可以使用此命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 .&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>

<p><strong>检测配置文件语法是否正确（重要）</strong></p>
<p>方式一：通过如下命令，指定需要检查的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 nginx -t -c  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>

<p>方式二：通过如下命令，不加 -c 参数，默认检测nginx.conf 配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 nginx -t</span><br></pre></td></tr></table></figure>



<h4 id="Docker-容器安装"><a href="#Docker-容器安装" class="headerlink" title="Docker 容器安装"></a>Docker 容器安装</h4><p>检查镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>下载nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>运行 nginx 并映射到 8080 端口,或者80:80还是原先的80端口，不可以不写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name my_nginx -p 8081:80 -d nginx</span><br></pre></td></tr></table></figure>

<p>检查端口是否开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 8080  &#x2F;&#x2F;端口已经开启了</span><br></pre></td></tr></table></figure>

<p>查看docker运行的端口服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps  &#x2F;&#x2F;nginx已经在运行了</span><br></pre></td></tr></table></figure>

<p>查看运行结果，再运行之前，请先检查你的防火墙是否已经开放了端口，如果没有需开放出一个端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost]# .&#x2F;openFirewallPort.sh  &#x2F;&#x2F;先在防火墙上开一个端口</span><br><span class="line">enter the port: </span><br><span class="line">8080</span><br><span class="line">success</span><br><span class="line"></span><br><span class="line">---openFirewallPort.sh-------</span><br><span class="line"> echo &quot;enter the port: &quot;</span><br><span class="line"> read port</span><br><span class="line"> firewall-cmd --add-port&#x3D;$port&#x2F;tcp</span><br></pre></td></tr></table></figure>

<p>出现上图中 Welcome to nginx! html画面则运行成功！</p>
<p><strong>需要注意：</strong><br>当docker运行nginx时，外界访问还是docker所在的那个IP地址，就相当于nginx在那台机器上运行一样。<br>但对于docker所在的那台机器来说，nginx就是附属于docker的一个镜像。若操作nginx还是由docker登录nginx容器，进行操作。<br>登录的nginx容器就是一个linux系统，只不过只有nginx而已，nginx按照linux默认路径安装。比如<br>root@zhang:/usr/share/nginx/html# ls 这个路径就是默认的静态页面存放路径<br>50x.html  index.html</p>
<p>bash命令都一样，但是vi在我机器上是不能用的，但可以使用cp、mv 等命令，因为nginx都是配置好的，不能乱改。</p>
<ul>
<li><p>可以通过在还未登录nignx容器前，把需要的文件写好，然后复制到指定目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ]# docker cp hello.html c0462d5e1878:&#x2F;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">[root@localhost ]# docker exec -it c0462d5e1878 bash</span><br><span class="line">root@c0462d5e1878:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# ls</span><br><span class="line">50x.html  hello.html  index.html</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>通过主机目录映射到容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 、docker  run  -p  80:80  -d  -v  $PWD&#x2F;html:usr&#x2F;share&#x2F;nginx&#x2F;html  docker.io&#x2F;nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、 -v  $PWD&#x2F;html:usr&#x2F;share&#x2F;nginx&#x2F;html  </span><br><span class="line"> 表示把当前路径下html目录映射为usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line"> 也就是说主机下的html就是容器下的usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line"> html内的文件修改和添加就等同于容器usr&#x2F;share&#x2F;nginx&#x2F;html文件操作</span><br><span class="line"> 外网访问就可以访问得到，就不用再登录容器操作文件了</span><br></pre></td></tr></table></figure>

<p><strong>停止、重启、 多开、卸载 服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps --查看nginx的端口信息</span><br><span class="line">docker stop my_nginx  --停止名称为my_nginx的镜像服务</span><br><span class="line">docker ps --查看nginx的端口信息</span><br><span class="line">docker start c079a3d5t979q0  --重启端口为c079a3d5t979q0的镜像服务</span><br><span class="line">docker run --name my_nginx_2 -p 8081:80 -d nginx --再开启一个服务，端口为8081</span><br><span class="line"></span><br><span class="line">docker ps   &#x2F;&#x2F;此时8080和8081都在运行</span><br><span class="line">docker stop my_nginx_2   &#x2F;&#x2F;停下8081</span><br><span class="line">docker ps  &#x2F;&#x2F;就剩8080还在运行</span><br><span class="line">docker ps -a &#x2F;&#x2F;可以看到8080在运行，8081已经Exited</span><br><span class="line">docker rm my_nginx_2  &#x2F;&#x2F;移除这个进行了的进程，注意运作着的进程是无法rm的，要先stop my_nginx_2</span><br></pre></td></tr></table></figure>

<p>将docker容器内的html、配置、日志文件拷贝到虚拟机本地文件夹目录中</p>
<p>创建如下文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~&#x2F;software&#x2F;nginx&#x2F;html  ~&#x2F;software&#x2F;nginx&#x2F;conf   ~&#x2F;software&#x2F;nginx&#x2F;logs</span><br></pre></td></tr></table></figure>

<p>拷贝容器内 Nginx 默认配置文件到本地当前目录下的 conf 目录，docker ps 可以查看容器 id 命令输入中的第一列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps --查看容器信息</span><br><span class="line">#开始拷贝</span><br><span class="line">docker cp f77f78d2228d:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf ~&#x2F;software&#x2F;nginx&#x2F;conf</span><br></pre></td></tr></table></figure>

<p>开启一个测试镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name my_nginx_test -p 8083:80 -d nginx -v ~&#x2F;software&#x2F;nginx&#x2F;conf -v ~&#x2F;software&#x2F;nginx&#x2F;html -v ~&#x2F;software&#x2F;nginx&#x2F;logs</span><br></pre></td></tr></table></figure>

<p>查询信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>访问  localhost:8083  报错 403 Forbidden 没有找到相关内容文件，这是因为开启的镜像是读的本地文件夹的内容，而我们并没有放html文件在里面 在  ~/software/nginx/html 文件夹下 创建  index.html 然后重新访问 localhost:8083  成功加载index.html 文件中的内容</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程学习（一）</title>
    <url>/2020/04/11/Java%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="JAVA中的线程"><a href="#JAVA中的线程" class="headerlink" title="JAVA中的线程"></a>JAVA中的线程</h1><p>在Java中，“线程”指两件不同的事情：<br>1）、java.lang.Thread类的一个实例；<br>2）、线程的执行。<br>使用java.lang.Thread类或者java.lang.Runnable接口编写代码来定义、实例化和启动新线程。<br>一个Thread类实例只是一个对象，像Java中的任何其他对象一样，具有变量和方法，生死于堆上。<br>Java中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。</p>
<p> 一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。<br>一旦创建一个新的线程，就产生一个新的调用栈。</p>
<p>线程总体分两类：<strong>用户线程</strong>和<strong>守候线程</strong>。<br>当所有用户线程执行完毕的时候，JVM自动关闭。<br>但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的</p>
<a id="more"></a>

<h2 id="五大状态"><a href="#五大状态" class="headerlink" title="五大状态"></a>五大状态</h2><p>线程的五大状态分别为：<strong>创建状态</strong>（New）、<strong>就绪状态</strong>（Runnable）、<strong>运行状态</strong>（Running）、<strong>阻塞状态</strong>（Blocked）、<strong>死亡状态</strong>（Dead）。</p>
<p><strong>线程的生命周期</strong></p>
<p>新建状态 -&gt; 就绪状态 -&gt; （运行状态 &lt;-&gt; 阻塞状态（有可能）） -&gt; 死亡状态</p>
<p><strong>扩展问题</strong></p>
<p>​     1、调用线程的start方法会是什么状态？ - <strong>就绪状态</strong></p>
<p>​     2、阻塞状态一定会执行吗？- 不会，当线程体的代码<strong>足够短</strong>的时候，线程会直接从运行状态到死亡状态</p>
<p>​     3、什么情况下会引起线程阻塞？</p>
<p>​         1）比如线程进行了某种耗时操作，访问网络等待网络的响应</p>
<p>​         2）线程调用了共享资源，但是发现该资源已经被上锁</p>
<p>​         3）线程本身调用了等待的代码（sleep、wait）</p>
<p>线程之间的关系转换<img src="/2020/04/11/Java%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/01_1.png"></p>
<h3 id="创建状态"><a href="#创建状态" class="headerlink" title="创建状态"></a>创建状态</h3><p>单纯地创建一个线程，创建线程有三种方式</p>
<p> 1、继承<strong>Thread</strong>类</p>
<p>  2、实现<strong>Runable</strong>的接口</p>
<p>  3、实现<strong>Callable</strong>接口 - 有返回值的线程</p>
<p>  4、线程池</p>
<hr>
<h3 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h3><p>在创建了线程之后，调用Thread类的 start() 方法来启动一个线程，表示线程进入就绪状态</p>
<hr>
<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>当线程获得CPU时间，线程才从就绪状态进入到运行状态</p>
<hr>
<h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>线程进入运行状态后，可能由于多种原因让线程进入阻塞状态<br>例如：调用sleep()方法让线程睡眠，调用wait()方法让线程等待，<br>           调用join()方法、suspend()方法（已被弃用）以及阻塞式IO方法等，都会造成线程的阻塞</p>
<hr>
<h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><p>run()  方法的正常退出就让线程进入到死亡状态。或者，当一个异常未被捕获而终止了run() 方法的执行也将进入到死亡状态。</p>
<hr>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h4 id="Thread类的线程操作重要方法"><a href="#Thread类的线程操作重要方法" class="headerlink" title="Thread类的线程操作重要方法"></a>Thread类的线程操作重要方法</h4><p><strong>setName()</strong> : 设置线程名称</p>
<p><strong>getName()</strong> : 获取线程名称</p>
<p><strong>run()</strong> : 线程的执行逻辑 </p>
<p><strong>start()</strong> : 启动线程</p>
<hr>
<p>yield() </p>
<p>线程让步，暂停线程的执行</p>
<p>1)、调用yield()方法让当前线程交出CPU权限，让CPU去执行其他线程。</p>
<p>2）、yield() 方法和 sleep() 方法类似，不会释放锁，但yield()方法不能控制具体交出CPU时间</p>
<p>3）、yield()方法只能让拥有相同优先级的线程去获取CPU执行的机会。</p>
<p>4）、使用yield()方法不会让线程进入阻塞状态，而是让线程从运行状态转换为就绪状态，只需要等待重新获取CPU执行的机会。</p>
<hr>
<p><strong>sleep(long millis)</strong> :线程休眠，暂停执行，但是不交出临界区的锁<br>1）、线程休眠会交出CPU资源，让CPU去执行其他的任务</p>
<p>2）、调用sleep()方法让线程进入休眠状态后，sleep()方法并不会释放锁，即当前线程持有某个对象锁时，即使调用sleep()方法其他线程也无法访问这个对象。</p>
<p>3）、调用sleep()方法让线程从运行状态转换为阻塞状态；sleep()方法调用结束后，线程从阻塞状态转换为可执行状态。</p>
<hr>
<p><strong>join(long millis)</strong> : 等待线程Kill , 如果在主线程中调用该方法时就会让主线程休眠，让调用join()方法的线程先执行完毕后再开始执行主线程。</p>
<hr>
<p><strong>stop()</strong> : kill一个线程，通常是通过线程内的循环条件来结束一个线程。不过该方法已被弃用。stop()方法会解除由线程获得的所有锁，当在一个线程对象上调用stop()方法时，这个线程对象所运行的线程会立即停止。</p>
<p>例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	x=<span class="number">1</span>;</span><br><span class="line">	y=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如一个线程正在执行一个同步的方法，多线程访问时总能保证x,y被同时赋值，而如果一个线程正在执行到x=1;时，被调用的stop()方法使得线程即使在同步方法中也要停止，这就造成了数据的不完整性。所以stop()方法是线程不安全的，已经被废弃，不建议使用。</p>
<hr>
<p><strong>interrupt()</strong> : 中断这个线程<br>1）、interrupt()方法只是改变中断状态而已，它不会中断一个正在运行的线程。具体来说就是，调用interrupt()方法只会给线程设置一个为true的中断标志，而设置之后，则根据线程当前状态进行不同的后续操作。</p>
<p>2）、如果线程的当前状态出于非阻塞状态，那么仅仅将线程的中断标志设置为true而已；</p>
<p>3）、如果线程的当前状态出于阻塞状态，那么将在中断标志设置为true后，还会出现wait()、sleep()、join()方法之一引起的阻塞，那么会将线程的中断标志位重新设置为false，并抛出一个InterruptedException异常。</p>
<p>4）、如果在中断时，线程正处于非阻塞状态，则将中断标志修改为true，而在此基础上，一旦进入阻塞状态，则按照阻塞状态的情况来进行处理。例如，一个线程在运行状态时，其中断标志设置为true之后，一旦线程调用了wait()、sleep()、join()方法中的一种，立马抛出一个InterruptedException异常，且中断标志被程序自动清除，重新设置为false。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//使用sleep()方法，使得线程由运行状态转换为阻塞状态</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="comment">//调用isInterrupted()方法，用于判断当前线程是否被中断</span></span><br><span class="line">				<span class="keyword">boolean</span> bool=Thread.currentThread().isInterrupted();</span><br><span class="line">				<span class="keyword">if</span>(bool) &#123;</span><br><span class="line">					System.out.println(<span class="string">"非阻塞状态下执行该操作，当前线程被中断!"</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">"第"</span>+(i++)+<span class="string">"次执行"</span>+<span class="string">" 线程名称："</span>+Thread.currentThread().getName());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"退出了！"</span>);</span><br><span class="line">				<span class="comment">//这里退出了阻塞状态，且中断标志bool被系统自动清除设置为false，所以此处的bool为false</span></span><br><span class="line">				<span class="keyword">boolean</span> bool=Thread.currentThread().isInterrupted();</span><br><span class="line">				System.out.println(bool);</span><br><span class="line">				<span class="comment">//退出run()方法，中断进程</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo_03</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		MyThread myThread=<span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread thread1=<span class="keyword">new</span> Thread(myThread,<span class="string">"自己创建的线程"</span>);</span><br><span class="line">		thread1.start();</span><br><span class="line">		<span class="comment">//让主线程sleep三秒</span></span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		<span class="comment">//调用interrupt()方法</span></span><br><span class="line">		thread1.interrupt();</span><br><span class="line">		 System.out.println(<span class="string">"代码结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">第<span class="number">0</span>次执行 线程名称：自己创建的线程</span><br><span class="line">第<span class="number">1</span>次执行 线程名称：自己创建的线程</span><br><span class="line">第<span class="number">2</span>次执行 线程名称：自己创建的线程</span><br><span class="line">代码结束</span><br><span class="line">退出了！</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>setPriority(int weight)</strong> : 设置线程的优先等级（1 -&gt;10）值越高，优先级越高 ，通常是5，并且子线程与母线程具有同等的优先级和线程属性（是否为前后台线程）。</p>
<p><strong>setDaemon(true)</strong> : 在 start() 方法前执行，将该线程设置为后台线程，后台线程在所有前台线程执行完后亦自行终止。</p>
<p><strong>isAlive()</strong> : 判断此线程是否处于处于活动状态，如果在 start() 后，线程终止前，该方法返回true。</p>
<hr>
<h4 id="Object类的线程操作重要方法"><a href="#Object类的线程操作重要方法" class="headerlink" title="Object类的线程操作重要方法"></a>Object类的线程操作重要方法</h4><p><strong>wait()</strong> : 将本线程放入wait池，放弃临界区的锁，直到其他拥有锁的线程使用 notify() 方法或者notifyAll()方法将该线程放入阻塞池(lock池)。</p>
<p>1）wait()方法的作用是让当前正在执行的线程进入线程阻塞状态的等待状态，该方法时用来将当前线程置入“预执行队列”中，并且调用wait()方法后，该线程在wait()方法所在的代码处停止执行，直到接到一些通知或被中断为止。</p>
<p>2）wait()方法只能在同步代码块或同步方法中调用，故如果调用wait()方法时没有持有适当的锁时，就会抛出异常。</p>
<p>3）wait()方法执行后，当前线程释放锁并且与其他线程相互竞争重新获得锁。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo_01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object object=<span class="keyword">new</span> Object();</span><br><span class="line">		<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">			System.out.println(<span class="string">"调用wait()前"</span>);</span><br><span class="line">			<span class="comment">//调用Object类的wait()方法</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				object.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"调用wait()后"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，程序依然处于执行状态。原本应该打印两条语句：调用wait()前 调用wait()后，但是由于该程序还没有运行完而且只打印了一条语句：调用wait()前。这是因为什么呢？因为调用了Object类的wait()方法，使得程序在执行wait()方法之后一直等待下去，故只执行了调用wait()方法前的语句。但程序不能这样一直等待下去，这个时候就需要另一个方法去唤醒调用wait()方法的处于等待状态的线程，让等待线程继续执行下去，该方法为notify()方法。</p>
<hr>
<p>*<em>notify()    notifyAll()  *</em> : 线程唤醒，将位于wait() 池中的线程放入阻塞池，等待获得临界区的锁</p>
<p><strong>notify()</strong> : </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>1）、notify()方法要在同步代码块或同步方法中调用。</p>
<p>2）、notify()方法是用来通知那些等待该对象的对象锁的线程，对其调用wait()方法的对象发出通知让这些线程不再等待，继续执行。</p>
<p>3）、如果有多个线程都在等待，则由线程规划器随机挑选出一个呈wait状态的线程将其线程唤醒，继续执行该线程。</p>
<p>4）、调用notify()方法后，当前线程并不会马上释放该对象锁，要等到执行notify()方法的线程执行完才会释放对象锁。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="keyword">private</span> Object obj;</span><br><span class="line">	<span class="comment">//定义一个构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">boolean</span> flag,Object object)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag=flag;</span><br><span class="line">		<span class="keyword">this</span>.obj=object;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个普通方法,其中调用了wait()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.obj) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"调用wait()前------"</span>+Thread.currentThread().getName());</span><br><span class="line">				<span class="comment">//调用wait()方法</span></span><br><span class="line">				<span class="keyword">this</span>.obj.wait();</span><br><span class="line">				System.out.println(<span class="string">"调用wait()后------"</span>+Thread.currentThread().getName());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个普通方法,其中调用了notify()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.obj) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"调用notify前------"</span>+Thread.currentThread().getName());</span><br><span class="line">				<span class="comment">//调用notify()方法</span></span><br><span class="line">				<span class="keyword">this</span>.obj.notify();</span><br><span class="line">				System.out.println(<span class="string">"调用notify()后------"</span>+Thread.currentThread().getName());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">			<span class="keyword">this</span>.waitThread();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.notifyThread();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo_03</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object object=<span class="keyword">new</span> Object();</span><br><span class="line">		<span class="comment">//实例化调用wait()的线程</span></span><br><span class="line">		MyThread wait=<span class="keyword">new</span> MyThread(<span class="keyword">true</span>,object);</span><br><span class="line">		Thread waitThread=<span class="keyword">new</span> Thread(wait,<span class="string">"wait线程"</span>);</span><br><span class="line">		<span class="comment">//实例化调用notify()的线程</span></span><br><span class="line">		MyThread notify=<span class="keyword">new</span> MyThread(<span class="keyword">false</span>,object);</span><br><span class="line">		Thread notifyThread=<span class="keyword">new</span> Thread(notify,<span class="string">"notify线程"</span>);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		waitThread.start();</span><br><span class="line">		<span class="comment">//调用一下sleep()方法，使得查看效果更明显</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		notifyThread.start();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用wait()前------wait线程</span><br><span class="line">调用notify前------notify线程</span><br><span class="line">调用notify()后------notify线程</span><br><span class="line">调用wait()后------wait线程</span><br><span class="line"></span><br><span class="line">根据run方法及实例化的线程对象，wait线程执行了waitThread()方法，该方法中调用了wait()方法使得线程进入线程阻塞状态的等待状态并释放锁，如果没有其他线程去唤醒该线程的话wait线程将一直等待下去。此时，notify线程执行了notifyThread()方法，该方法中调用了notify()方法，使得notify线程去唤醒wait线程，让wait线程不再等待下去，并且先将notify线程执行完后释放锁再执行wait线程的wait()方法之后的语句.但要注意的是，当有多个线程处于等待时，调用notify()方法唤醒线程时，就会依然有线程处于等待状态,如下面这个例子</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread_2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="keyword">private</span> Object obj;</span><br><span class="line">	<span class="comment">//定义一个构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">boolean</span> flag,Object object)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag=flag;</span><br><span class="line">		<span class="keyword">this</span>.obj=object;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个普通方法,其中调用了wait()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.obj) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"调用wait()前------"</span>+Thread.currentThread().getName());</span><br><span class="line">				<span class="comment">//调用wait()方法</span></span><br><span class="line">				<span class="keyword">this</span>.obj.wait();</span><br><span class="line">				System.out.println(<span class="string">"调用wait()后------"</span>+Thread.currentThread().getName());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个普通方法,其中调用了notify()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.obj) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"调用notify前------"</span>+Thread.currentThread().getName());</span><br><span class="line">				<span class="comment">//调用notify()方法</span></span><br><span class="line">				<span class="keyword">this</span>.obj.notify();</span><br><span class="line">				System.out.println(<span class="string">"调用notify()后------"</span>+Thread.currentThread().getName());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">			<span class="keyword">this</span>.waitThread();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.notifyThread();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_04</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object object=<span class="keyword">new</span> Object();</span><br><span class="line">		<span class="comment">//实例化调用wait()的线程</span></span><br><span class="line">		MyThread wait=<span class="keyword">new</span> MyThread(<span class="keyword">true</span>,object);</span><br><span class="line">		Thread waitThread1=<span class="keyword">new</span> Thread(wait,<span class="string">"wait线程1"</span>);</span><br><span class="line">		Thread waitThread2=<span class="keyword">new</span> Thread(wait,<span class="string">"wait线程2"</span>);</span><br><span class="line">		Thread waitThread3=<span class="keyword">new</span> Thread(wait,<span class="string">"wait线程3"</span>);</span><br><span class="line">		<span class="comment">//实例化调用notify()的线程</span></span><br><span class="line">		MyThread notify=<span class="keyword">new</span> MyThread(<span class="keyword">false</span>,object);</span><br><span class="line">		Thread notifyThread=<span class="keyword">new</span> Thread(notify,<span class="string">"notify线程"</span>);</span><br><span class="line">		<span class="comment">//启动3个等待线程</span></span><br><span class="line">		waitThread1.start();</span><br><span class="line">		waitThread2.start();</span><br><span class="line">		waitThread3.start();</span><br><span class="line">		<span class="comment">//调用一下sleep()方法，使得查看效果更明显</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		notifyThread.start();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用wait()前------wait线程<span class="number">1</span></span><br><span class="line">调用wait()前------wait线程<span class="number">3</span></span><br><span class="line">调用wait()前------wait线程<span class="number">2</span></span><br><span class="line">调用notify前------notify线程</span><br><span class="line">调用notify()后------notify线程</span><br><span class="line">调用wait()后------wait线程<span class="number">1</span></span><br><span class="line"></span><br><span class="line">此时程序并没有执行完毕，因为依然有线程处于等待状态，所以notify()只是随机将某一个等待线程唤醒，并没有唤醒所有等待线程。那么，若有多个线程处于等待状态时，如何将所有等待线程都唤醒呢，不是还有个 notifyAll()方法一直没说嘛</span><br></pre></td></tr></table></figure>

<p><strong>notifyAll()</strong> : 将同一对象锁的所有等待线程全部唤醒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread_3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="keyword">private</span> Object obj;</span><br><span class="line">	<span class="comment">//定义一个构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">boolean</span> flag,Object object)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag=flag;</span><br><span class="line">		<span class="keyword">this</span>.obj=object;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个普通方法,其中调用了wait()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.obj) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"调用wait()前------"</span>+Thread.currentThread().getName());</span><br><span class="line">				<span class="comment">//调用wait()方法</span></span><br><span class="line">				<span class="keyword">this</span>.obj.wait();</span><br><span class="line">				System.out.println(<span class="string">"调用wait()后------"</span>+Thread.currentThread().getName());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义一个普通方法,其中调用了notifyAll()方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.obj) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"调用notify前------"</span>+Thread.currentThread().getName());</span><br><span class="line">				<span class="comment">//调用notifyAll()方法</span></span><br><span class="line">				<span class="keyword">this</span>.obj.notifyAll();</span><br><span class="line">				System.out.println(<span class="string">"调用notify()后------"</span>+Thread.currentThread().getName());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">			<span class="keyword">this</span>.waitThread();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.notifyThread();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object object=<span class="keyword">new</span> Object();</span><br><span class="line">		<span class="comment">//实例化调用wait()的线程</span></span><br><span class="line">		MyThread wait=<span class="keyword">new</span> MyThread(<span class="keyword">true</span>,object);</span><br><span class="line">		Thread waitThread1=<span class="keyword">new</span> Thread(wait,<span class="string">"wait线程1"</span>);</span><br><span class="line">		Thread waitThread2=<span class="keyword">new</span> Thread(wait,<span class="string">"wait线程2"</span>);</span><br><span class="line">		Thread waitThread3=<span class="keyword">new</span> Thread(wait,<span class="string">"wait线程3"</span>);</span><br><span class="line">		<span class="comment">//实例化调用notifyAll()的线程</span></span><br><span class="line">		MyThread notify=<span class="keyword">new</span> MyThread(<span class="keyword">false</span>,object);</span><br><span class="line">		Thread notifyThread=<span class="keyword">new</span> Thread(notify,<span class="string">"notify线程"</span>);</span><br><span class="line">		<span class="comment">//启动3个等待线程</span></span><br><span class="line">		waitThread1.start();</span><br><span class="line">		waitThread2.start();</span><br><span class="line">		waitThread3.start();</span><br><span class="line">		<span class="comment">//调用一下sleep()方法，使得查看效果更明显</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		notifyThread.start();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用wait()前------wait线程<span class="number">1</span></span><br><span class="line">调用wait()前------wait线程<span class="number">2</span></span><br><span class="line">调用wait()前------wait线程<span class="number">3</span></span><br><span class="line">调用notify前------notify线程</span><br><span class="line">调用notify()后------notify线程</span><br><span class="line">调用wait()后------wait线程<span class="number">3</span></span><br><span class="line">调用wait()后------wait线程<span class="number">2</span></span><br><span class="line">调用wait()后------wait线程<span class="number">1</span></span><br><span class="line"></span><br><span class="line">此时程序执行完毕，所有等待线程都被调用notifyAll()方法的具有同一对象锁的线程唤醒，每一个等待线程都会在调用wait()后继续执行直到该线程结束</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>扩展问题：</strong>线程调用 <strong>start()</strong>  方法 和调用 <strong>run()</strong>方法又什么区别？</p>
<p>调用start 方法会在内存中开启一个线程，和当前线程争抢CPU时间片<br>直接调用run方法相当于在当前线程执行run方法的方法体（同步的）</p>
<p><strong>扩展：实现Runable相对Thread的一点好处在于：</strong><br>实现Runable接口的方式来创建线程，可以在多个线程中执行一个共同的资源，只需创建好一个实现Runable接口的Runable实现类放在所创建的不同Thread类的里参数中即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(myRunnable）;             </span><br><span class="line">thread1.start();</span><br><span class="line"></span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<p>例1：多个线程共享同一个资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick_test = <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tick_test&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"卖出票："</span> + tick_test--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnableTest myRunnable = <span class="keyword">new</span> MyRunnableTest();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myRunnable, <span class="string">"窗口1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(myRunnable, <span class="string">"窗口2"</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(myRunnable, <span class="string">"窗口3"</span>);</span><br><span class="line">        </span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle整理（一）</title>
    <url>/2020/03/29/Oracle%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><strong>前言：</strong>大学学习了的Oracle，毕业之后就动过寥寥数次，后面一直用SqlServer MySql，最近重新复习Oracle的面试题，就一边看写一边个笔记上Blog交作业。</p>
<a id="more"></a>

<h5 id="1、对数据库SQLServer2005、Oracle熟悉吗？"><a href="#1、对数据库SQLServer2005、Oracle熟悉吗？" class="headerlink" title="1、对数据库SQLServer2005、Oracle熟悉吗？"></a>1、对数据库SQLServer2005、Oracle熟悉吗？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLServer2005是Microsoft 公司的数据库产品。是一个RDBMS数据库，一般用在一些中型数据库的产品应用上。不能跨平台</span><br><span class="line">Oracle 是ORACLE 公司的数据库产品，支持海量数据库存储，支持分布式部署，支持多用户，跨平台，数据库安全完整性控制性能优越，是一个ORDBMS,一般用在大型公司。</span><br></pre></td></tr></table></figure>

<h5 id="2、什么是RDBMS，ORDBMS"><a href="#2、什么是RDBMS，ORDBMS" class="headerlink" title="2、什么是RDBMS，ORDBMS"></a>2、什么是RDBMS，ORDBMS</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RDBMS的全拼是Relational Database Management System，从字面上可以理解为关系数据库管理系统。</span><br><span class="line">它是SQL的基础，对于像MS SQLServer，IBM DB2，Oracle，MySQL和Microsoft Access等所有现代数据库系统。</span><br><span class="line">这两者的概念区别：</span><br><span class="line">一个是关系数据库管理系统(RDBMS)一个是数据库管理系统(DBMS)，基于关系模型如通过 E. F. Codd 引入。</span><br><span class="line"></span><br><span class="line">ORDBMS（Object Relational Database Management System） 对象关系数据库系统在实质上还是关系数据库</span><br></pre></td></tr></table></figure>

<h5 id="3、一般用什么工具设计数据库，如何实现数据库的导入与到导出的更新"><a href="#3、一般用什么工具设计数据库，如何实现数据库的导入与到导出的更新" class="headerlink" title="3、一般用什么工具设计数据库，如何实现数据库的导入与到导出的更新"></a>3、一般用什么工具设计数据库，如何实现数据库的导入与到导出的更新</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">业内一般使用 POWERDISINE 工具设计数据库 ，一般满足第三范式就可以。</span><br><span class="line"></span><br><span class="line">EXP和IMP命令操作数据库的逻辑导入与导出</span><br><span class="line">exp导出方式：</span><br><span class="line"></span><br><span class="line">1\导出用户自身拥有的表并带有数据： 导出自己的表到data-bak目录下。</span><br><span class="line">语法：exp userid&#x3D;uname&#x2F;pwd tables&#x3D;table-name file&#x3D;&#x2F;data-bak&#x2F;table-name.dmp;</span><br><span class="line"></span><br><span class="line">2\只导出表结构</span><br><span class="line">语法：exp userid&#x3D;uname&#x2F;pwd  tables&#x3D;table-name  file&#x3D;&#x2F;home&#x2F;data-bak&#x2F;table-name.dmp rows&#x3D;n;</span><br><span class="line"></span><br><span class="line">3\导出其它用户的表或者表结构(只有管理员或者具有DBA权限的用户可以操作)</span><br><span class="line">语法：exp userid&#x3D;uname&#x2F;pwd tables&#x3D;table-name file&#x3D;&#x2F;home&#x2F;oracle&#x2F;data-back&#x2F;table-name.dmp</span><br><span class="line"></span><br><span class="line">4\导出用户自身的方案，此命令会将该用户下的表 视图 同义词 存储过程之类的数据全部导出。</span><br><span class="line">语法：exp userid&#x3D;uname&#x2F;pwd owner&#x3D;uname file&#x3D;&#x2F;home&#x2F;oracle&#x2F;data-bak&#x2F;table-name.dmp;</span><br><span class="line"></span><br><span class="line">5\导出整个数据库,导出整个库的过程很慢。</span><br><span class="line">语法：exp userid&#x3D;system&#x2F;manager full&#x3D;y  </span><br><span class="line">     inctype&#x3D;complete file&#x3D;&#x2F;home&#x2F;oracle&#x2F;data-bak&#x2F;database.dmp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">imp导入与导出类似，这里只写一个导入表操作。</span><br><span class="line">导入自身的表</span><br><span class="line">语法：imp userid&#x3D;uname&#x2F;pwd tables&#x3D;ce file&#x3D;&#x2F;home&#x2F;oracle&#x2F;data-bak&#x2F;ce.dmp;</span><br><span class="line"></span><br><span class="line">扩：</span><br><span class="line">数据库的导入与更新一般都涉及到Oracle备份，oracle备份方式有两种：</span><br><span class="line">1.物理备份</span><br><span class="line">物理备份是将数据库的数据文件拷贝到服务器或者其它介质上。当数据库出现问题时直接从服务器或者介质上面拷贝回来。</span><br><span class="line">2.逻辑备份</span><br><span class="line">逻辑备份主要是利用导入导出工具进行备份与恢复的操作。</span><br><span class="line">3.两种备份共同点与不同点：</span><br><span class="line">物理备份可在数据库open的状态下进行，也可以在关闭数据库后进行。</span><br><span class="line">逻辑备份和恢复只能在open的状态下进行。</span><br><span class="line">exp   expdp   imp impdp只能在数据库open的状态下进行备份，</span><br><span class="line">在数据库打开的状态下逻辑备份和物理备份都可以。</span><br></pre></td></tr></table></figure>

<h5 id="3、1-数据库的三大范式"><a href="#3、1-数据库的三大范式" class="headerlink" title="3、1 数据库的三大范式"></a>3、1 数据库的三大范式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1NF:每个属性是不可分的。</span><br><span class="line">2NF:若关系R是１NF,且每个非主属性都完全函数依赖于R的键。</span><br><span class="line">例SLC(SID#, CourceID#, SNAME,Grade),则不是2NF;</span><br><span class="line">3NF:若R是2NF，且它的任何非键属性都不传递依赖于任何候选键。</span><br></pre></td></tr></table></figure>

<h5 id="4、如何只显示重复数据，或者不显示重复数据？"><a href="#4、如何只显示重复数据，或者不显示重复数据？" class="headerlink" title="4、如何只显示重复数据，或者不显示重复数据？"></a>4、如何只显示重复数据，或者不显示重复数据？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">显示重复数据： SELECT * FROM TABLE_NAME GROUP BY I_D HAVING COUNT(*)&gt;1</span><br><span class="line">不显示重复数据： SELECT * FROM TABLE_NAME GROUP BY I_D HAVING COUNT(*)&#x3D;1</span><br></pre></td></tr></table></figure>

<h5 id="5、SQL分页有哪些方法？如何用存储过程写一个分页？用一个SQL语句写一个分页"><a href="#5、SQL分页有哪些方法？如何用存储过程写一个分页？用一个SQL语句写一个分页" class="headerlink" title="5、SQL分页有哪些方法？如何用存储过程写一个分页？用一个SQL语句写一个分页"></a>5、SQL分页有哪些方法？如何用存储过程写一个分页？用一个SQL语句写一个分页</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在SQLSERVER中使用TOP分页，在ORACLE中用ROWNUM，或分析函数ROW_NUMBER，在MYSQL中用LIMT分页</span><br><span class="line">使用TOP分页：</span><br><span class="line">SELECT TOP 20,n.* FROM TABLE_NAME N </span><br><span class="line">MINUS </span><br><span class="line">SELECT TOP 10,m.* FROM TABLE_NAME M</span><br><span class="line">[注意：] MINUS指令是运用在两个SQL语句上。</span><br><span class="line">它先找出第一个SQL语句所产生的结果，然后看这些结果有没有在第二个SQL语句的结果中。</span><br><span class="line">如果有的话，那这一笔资料就被去除，而不会在最后的结果中出现。</span><br><span class="line">如果第二个SQL语句所产生的结果并没有存在于第一个SQL语句所产生的结果内，那这笔资料就被抛弃。</span><br><span class="line"></span><br><span class="line">使用分析函数ROW_NUMBER</span><br><span class="line">SELECT *FROM (SELECT N.*,ROW_NUMBER() OVER(ORDER BY COLUMN_NAME)NUM FROM TABLE_NAME n )</span><br><span class="line">使用过程中，只要将分页的范围用两个参数就可以实现。在ORACLE中，要将过程封装在包里，还要用动态游标变量才能实现数据集的返回。</span><br><span class="line"></span><br><span class="line">至于如何用存储过程写一个分页，我真的太久没写了，等下次写好再更新叭......</span><br></pre></td></tr></table></figure>

<h5 id="6、ORACLE-中左连接、右连接"><a href="#6、ORACLE-中左连接、右连接" class="headerlink" title="6、ORACLE 中左连接、右连接"></a>6、ORACLE 中左连接、右连接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左连接： LEFT JOIN 右连接： RIGHT JOIN</span><br><span class="line">SELECT n.COLUMN_NAME,m.COLUMN_NAME </span><br><span class="line">FROM TABLE_NAME_1 n LEFT JOIN TABLE_NAME_2 m</span><br><span class="line">ON n.COLUMN_NAME&#x3D;m.COLUMN_NAME</span><br><span class="line">用 WHERE 实现</span><br><span class="line">SELECT n.COLUMN_NAME,m.COLUMN_NAME </span><br><span class="line">FROM TABLE_NAME_1 n,TABLE_NAME_2 m</span><br><span class="line">WHERE n.COLUMN_NAME(+)&#x3D;m.COLUMN_NAME</span><br><span class="line"></span><br><span class="line">上面两个语法使用 左连接 LEFT JOIN 替换成 如果要右连接，</span><br><span class="line">把关键字换了就行，这里要说明的是关于左连接和右连接的两个概念。以及扩展的内连接和外连接</span><br><span class="line">1）、基础表不同</span><br><span class="line">a、左连接：左连接的基础表为left join左侧数据表,返回包括左表中的所有记录和右表中连接字段相等的记录。</span><br><span class="line">b、右连接：右连接的基础表为right join右侧数据表,返回包括右表中的所有记录和左表中连接字段相等的记录。</span><br><span class="line"></span><br><span class="line">2）、[扩展] 假设有 A B 两张表</span><br><span class="line">a、inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。（只有2张表匹配的行才能显示）</span><br><span class="line">  例子：select a.name,b.job from A a  inner join B b on a.id&#x3D;b.A_id</span><br><span class="line">  </span><br><span class="line">b、full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。(左右2张表都不加限制）</span><br><span class="line">  例子：select a.name,b.job from A a  full join B b on a.id&#x3D;b.A_id</span><br></pre></td></tr></table></figure>

<h5 id="7、什么是反射、序列化、反序列化？事务有几种级别？"><a href="#7、什么是反射、序列化、反序列化？事务有几种级别？" class="headerlink" title="7、什么是反射、序列化、反序列化？事务有几种级别？"></a>7、什么是反射、序列化、反序列化？事务有几种级别？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反射是在程序运行时动态访问DDL的一种方式。</span><br><span class="line">序列化是将对象对二进制、XML等方式直接向文件的存储。</span><br><span class="line">反序列化是将存储到文件的对象取出的过程。</span><br><span class="line">事务的级别的三种：页面级、应用程序级、数据库级。</span><br></pre></td></tr></table></figure>

<h5 id="8、数据测试如何测试？"><a href="#8、数据测试如何测试？" class="headerlink" title="8、数据测试如何测试？"></a>8、数据测试如何测试？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在PLSQL里对存储过程或函数可能会通过专用的测试工具进行测试，</span><br><span class="line">通过专门准备的海量数据对存储过程或者函数进行性能测试。</span><br></pre></td></tr></table></figure>

<h5 id="9、用事务的时候，如果在业务逻辑层中，调用数据库访问层中的方法，访问层中有很多类，类又有很多方法，每个方法都要实现，那么如何处理？"><a href="#9、用事务的时候，如果在业务逻辑层中，调用数据库访问层中的方法，访问层中有很多类，类又有很多方法，每个方法都要实现，那么如何处理？" class="headerlink" title="9、用事务的时候，如果在业务逻辑层中，调用数据库访问层中的方法，访问层中有很多类，类又有很多方法，每个方法都要实现，那么如何处理？"></a>9、用事务的时候，如果在业务逻辑层中，调用数据库访问层中的方法，访问层中有很多类，类又有很多方法，每个方法都要实现，那么如何处理？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通用数据访问层的实现？？？（你特喵的能说具体一点吗）</span><br><span class="line">容我思考一下，再更新这个答案......</span><br></pre></td></tr></table></figure>

<h5 id="9-1、什么是事务？"><a href="#9-1、什么是事务？" class="headerlink" title="9.1、什么是事务？"></a>9.1、什么是事务？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。</span><br><span class="line">事务性质：原子性、一致性、隔离性、持久性</span><br><span class="line">原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</span><br><span class="line">一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态</span><br><span class="line">隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，</span><br><span class="line">持久性：事务正确提交后，其结果将永久保存在数据库中，</span><br><span class="line">       即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</span><br></pre></td></tr></table></figure>

<h5 id="9-3、什么是存储过程？为什么用存储过程（有哪些优点）？"><a href="#9-3、什么是存储过程？为什么用存储过程（有哪些优点）？" class="headerlink" title="9.3、什么是存储过程？为什么用存储过程（有哪些优点）？"></a>9.3、什么是存储过程？为什么用存储过程（有哪些优点）？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储过程：存储过程就是已经编译好了的一大段sql语句放到一个类似于代码包里的sql语句。</span><br><span class="line">1.存储过程因为SQL语句已经预编绎过了，因此运行的速度比较快。</span><br><span class="line">2.可以保证数据的安全性和完整性。通过存储过程可以使没有权限的用户在控制之下间接地存取数据库。</span><br><span class="line">  从而保证数据的安全。通过存储过程可以使相关的动作在一起发生，从而可以维护数据库的完整性。</span><br><span class="line">3.可以降低网络的通信量。存储过程主要是在服务器上运行，减少对客户机的压力。</span><br><span class="line">4：存储过程可以接受参数、输出参数、返回单个或多个结果集以及返回值。可以向程序返回错误原因</span><br><span class="line">5：存储过程可以包含程序流、逻辑以及对数据库的查询。同时可以实体封装和隐藏了数据逻辑。</span><br></pre></td></tr></table></figure>

<h5 id="10、什么时候会用到触发器"><a href="#10、什么时候会用到触发器" class="headerlink" title="10、什么时候会用到触发器"></a>10、什么时候会用到触发器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">触发器（trigger）是个特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，</span><br><span class="line">比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。 触发器可以从 DBA_TRIGGERS ，USER_TRIGGERS 数据字典中查到。</span><br><span class="line"></span><br><span class="line">另外在做 安全管理、日志管理、复杂业务逻辑实现的时候都会使用到触发器</span><br><span class="line"></span><br><span class="line">触发器的优点</span><br><span class="line">触发器可通过数据库中的相关表实现级联更改，不过，通过级联引用完整性约束可以更有效地执行这些更改。</span><br><span class="line">触发器可以强制比用CHECK约束定义的约束更为复杂的约束。与 CHECK 约束不同，触发器可以引用其它表中的列。</span><br><span class="line">例如，触发器可以使用另一个表中的 SELECT 比较插入或更新的数据，以及执行其它操作，</span><br><span class="line">如修改数据或显示用户定义错误信息。触发器也可以评估数据修改前后的表状态，</span><br><span class="line">并根据其差异采取对策。一个表中的多个同类触发器（INSERT、UPDATE 或 DELETE）</span><br><span class="line">允许采取多个不同的对策以响应同一个修改语句</span><br></pre></td></tr></table></figure>

<h5 id="11、如何在数据库中显示树控制？"><a href="#11、如何在数据库中显示树控制？" class="headerlink" title="11、如何在数据库中显示树控制？"></a>11、如何在数据库中显示树控制？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用父ID和子ID来实现</span><br><span class="line">Oracle 9i 开始，可以通过 SYS_CONNECT_BY_PATH 函数实现将从父节点到</span><br><span class="line">当前行内容以“path”或者层次元素列表的形式显示出来。</span><br><span class="line"></span><br><span class="line">Oracle 10g 开始，可以使用 START WITH . . . CONNECT BY . . .</span><br><span class="line">主从句可将父级与子级连接起来，并将其层次等级以树状显示出来。 </span><br><span class="line"></span><br><span class="line">Oracle 10g 中的新特性——CONNECT_BY_ROOT。 它用在列名之前用于返回当前层的根节点。</span><br><span class="line">在Oracle 10g 之前的版本中，如果在你的树中出现了环状循环（如一个孩子节点引用一个父亲节点），</span><br><span class="line">Oracle 就会报出一个错误提示：</span><br><span class="line">“ ORA-01436: CONNECT BY loop in user data”。如果不删掉对父亲的引用就无法执行查询操作。</span><br><span class="line">而在 Oracle 10g 中，只要指定“NOCYCLE”就可以进行任意的查询操作。</span><br><span class="line">与这个关键字相关的还有一个伪列——CONNECT_BY_ISCYCLE， </span><br><span class="line">如果在当前行中引用了某个父亲节点的内容并在树中出现了循环，那么该行的伪列中就会显示“1”，</span><br><span class="line">否则就显示“0”。而这个功能就可以帮助我们校验一直让我们头疼不已的BOM结构死循环（大多由于数据导入形成的）</span><br></pre></td></tr></table></figure>

<h5 id="12、如何实现数据库的优化？"><a href="#12、如何实现数据库的优化？" class="headerlink" title="12、如何实现数据库的优化？"></a>12、如何实现数据库的优化？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A、调整数据结构的设计。这一部分在开发信息系统之前完成，</span><br><span class="line">程序员需要考虑是否使用ORACLE数据库的分区功能，</span><br><span class="line">对于经常访问的数据库表是否需要建立索引等。</span><br><span class="line"></span><br><span class="line">B、调整应用程序结构设计。这一部分也是在开发信息系统之前完成，</span><br><span class="line">程序员在这一步需要考虑应用程序使用什么样的体系结构，</span><br><span class="line">是使用传统的Client&#x2F;Server两层体系结构，还是使用Browser&#x2F;Web&#x2F;Database的三层体系结构。</span><br><span class="line">不同的应用程序体系结构要求的数据库资源是不同的。</span><br><span class="line"></span><br><span class="line">C、调整数据库SQL语句。应用程序的执行最终将归结为数据库中的SQL语句执行，</span><br><span class="line">因此SQL语句的执行效率最终决定了ORACLE数据库的性能。</span><br><span class="line">ORACLE公司推荐使用ORACLE语句优化器（OracleOptimizer）和行锁管理器（row-levelmanager）来调整优化SQL语句。</span><br><span class="line"></span><br><span class="line">D、调整服务器内存分配。内存分配是在信息系统运行过程中优化配置的，</span><br><span class="line">数据库管理员可以根据数据库运行状况调整数据库系统全局区（SGA区）的数据缓冲区、日志缓冲区和共享池的大小；</span><br><span class="line">还可以调整程序全局区（PGA区）的大小。需要注意的是，SGA区不是越大越好，</span><br><span class="line">SGA区过大会占用操作系统使用的内存而引起虚拟内存的页面交换，这样反而会降低系统性能。</span><br><span class="line"></span><br><span class="line">E、调整硬盘I&#x2F;O，这一步是在信息系统开发之前完成的。</span><br><span class="line">数据库管理员可以将组成同一个表空间的数据文件放在不同的硬盘上，做到硬盘之间I&#x2F;O负载均衡。</span><br><span class="line"></span><br><span class="line">F、调整操作系统参数</span><br><span class="line">例如：运行在UNIX操作系统上的ORACLE数据库，可以调整UNIX</span><br><span class="line">数据缓冲池的大小，每个进程所能使用的内存大小等参数。</span><br></pre></td></tr></table></figure>

<h5 id="13、如何使用Oracle的游标？"><a href="#13、如何使用Oracle的游标？" class="headerlink" title="13、如何使用Oracle的游标？"></a>13、如何使用Oracle的游标？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">游标（Cursor）</span><br><span class="line">在写java程序中有集合的概念，那么在pl&#x2F;sql中也会用到多条记录，这时候要用到游标，游标可以存储查询返回的多条数据</span><br><span class="line">语法：</span><br><span class="line">CURSOR 游标名 [(参数名 数据类型， 参数名 数据类型…)] IS SELECT 语句；</span><br><span class="line">例如：cursor c1 is select ename from emp;</span><br><span class="line">游标的使用步骤：</span><br><span class="line">1、打开游标： open c1;（打开游标执行查询）</span><br><span class="line">取一行游标的值: fetch c1 into pjob;（取一行到变量中）</span><br><span class="line">2、关闭游标：close c1;（关闭游标释放资源）</span><br><span class="line">游标的结束方式 exit when c1 %notfound</span><br><span class="line"></span><br><span class="line">注意：上面的pjob必须与emp表中的job列类型一致</span><br><span class="line">定义：pjob emp.empjob%type;</span><br><span class="line"></span><br><span class="line">示例：不带参数的游标</span><br><span class="line">declare </span><br><span class="line">   --定义光标（游标）</span><br><span class="line">   --CURSOR 游标名 [(参数名 数据类型， 参数名 数据类型…)] IS SELECT 语句；</span><br><span class="line">   cursor cemp is select ename,sal from emp;</span><br><span class="line">   -- 定义字段</span><br><span class="line">   pename emp.ename%type; -- 姓名</span><br><span class="line">   psal   emp.sal%type;  -- 薪水</span><br><span class="line">--开始</span><br><span class="line">begin</span><br><span class="line">  --打开</span><br><span class="line">  open cemp;</span><br><span class="line">  --开始</span><br><span class="line">  loop</span><br><span class="line">       --取当前记录</span><br><span class="line">       fetch cemp into pename,psal;</span><br><span class="line">       --exit when 没有取到记录;</span><br><span class="line">       exit when cemp%notfound;</span><br><span class="line"></span><br><span class="line">       --取道结果，然后输出</span><br><span class="line">       dbms_output.put_line(pename||&#39;的薪水是&#39;||psal);</span><br><span class="line">  --结束</span><br><span class="line">  end loop;</span><br><span class="line"></span><br><span class="line">  --关闭</span><br><span class="line">  close cemp;</span><br><span class="line">--结束</span><br><span class="line">end;</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">示例2：带参数的游标</span><br><span class="line"></span><br><span class="line">-- 查询某个部门的员工姓名</span><br><span class="line">declare </span><br><span class="line">   --形参</span><br><span class="line">   --CURSOR 游标名 [(参数名 数据类型， 参数名 数据类型…)] IS SELECT 语句；</span><br><span class="line">   cursor cemp(dno number) is select ename from emp where deptno&#x3D;dno;</span><br><span class="line">   -- 姓名字段</span><br><span class="line">   pename emp.ename%type; </span><br><span class="line">begin</span><br><span class="line">   --实参</span><br><span class="line">   open cemp(20);</span><br><span class="line">   --开始</span><br><span class="line">   loop</span><br><span class="line">        --取当前记录</span><br><span class="line">        fetch cemp into pename;</span><br><span class="line">        --exit when 没有取到记录;</span><br><span class="line">        exit when cemp%notfound;</span><br><span class="line">        --取道记录，输出结果</span><br><span class="line">        dbms_output.put_line(pename);</span><br><span class="line"></span><br><span class="line">  --结束</span><br><span class="line">   end loop;</span><br><span class="line">   </span><br><span class="line">   --关闭</span><br><span class="line">   close cemp;</span><br><span class="line">end;</span><br><span class="line">&#x2F;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习（二）</title>
    <url>/2020/03/31/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>前面一篇笔记复习了下Nginx的简单使用以及部署，一般Nginx部署之后其他的基本上不用动了，只需要配置就好了，包括使用Nginx也是通过修改一些列配置实现的，这几天有空的时候仔细过了一遍Nginx的配置原理以及逻辑架构，代理、正反向代理，代理操作指令等，写下这篇笔记。</p>
<h2 id="Conf配置文件详解"><a href="#Conf配置文件详解" class="headerlink" title="Conf配置文件详解"></a>Conf配置文件详解</h2><a id="more"></a>

<p>首先在虚拟机上进入到你的conf文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、cd ~&#x2F;user&#x2F;software&#x2F;nginx&#x2F;conf</span><br><span class="line">2、 ll</span><br></pre></td></tr></table></figure>

<p>找到 名为 <strong>nginx.conf</strong> 的文件 这个文件就是他的配置文件，然后我们来看一下里面的内容</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">#Nginx 服务器并发处理服务的关键配置，</span></span><br><span class="line">  <span class="comment">#worker_processes 值越大，可以支持的并发处理量也越多，</span></span><br><span class="line">  <span class="comment">#但是会受到硬件、软件等设备的制约</span></span><br><span class="line">  worker_processes  <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">#error_log  logs/error.log;</span></span><br><span class="line">   <span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line">   <span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">#服务器与用户的网络连接设置，最大连接数为1024</span></span><br><span class="line">  events &#123;</span><br><span class="line">      worker_connections  <span class="number">1024</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#http 全局块</span></span><br><span class="line">　<span class="comment">#http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</span></span><br><span class="line">  http &#123;</span><br><span class="line">      include       mime.types;</span><br><span class="line">      default_type  application/octet-stream;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">      <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">      <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line">  </span><br><span class="line">      sendfile        on;</span><br><span class="line">      <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">      keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">#gzip  on;</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">#这块和虚拟主机有密切关系，虚拟主机从用户角度看，</span></span><br><span class="line">      <span class="comment">#和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</span></span><br><span class="line">      <span class="comment">#每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。</span></span><br><span class="line">      <span class="comment">#而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</span></span><br><span class="line">      server &#123;</span><br><span class="line">          <span class="keyword">listen</span>       <span class="number">80</span>;</span><br><span class="line">          server_name  localhost;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">#charset koi8-r;</span></span><br><span class="line">  </span><br><span class="line">          <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">  </span><br><span class="line">          location / &#123;</span><br><span class="line">              root   html;</span><br><span class="line">              <span class="keyword">index</span>  index.html index.htm;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">  </span><br><span class="line">          <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">          <span class="comment"># 一个 server 块可以配置多个 location 块。</span></span><br><span class="line">          <span class="comment">#这块的主要作用是基于 Nginx  服务器接收到的请求字符串</span></span><br><span class="line">          <span class="comment">#（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串</span></span><br><span class="line">          <span class="comment">#（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、</span></span><br><span class="line">          <span class="comment">#数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</span></span><br><span class="line">          error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">          location = <span class="regexp">/50x.html &#123;</span></span><br><span class="line"><span class="regexp">              root   html;</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">          # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line"><span class="regexp">          #</span></span><br><span class="line"><span class="regexp">          #location ~ \.php$ &#123;</span></span><br><span class="line"><span class="regexp">          #    proxy_pass   http:/</span><span class="regexp">/127.0.0.1;</span></span><br><span class="line"><span class="regexp">          #&#125;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">          # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="regexp">          #</span></span><br><span class="line"><span class="regexp">          #location ~ \.php$ &#123;</span></span><br><span class="line"><span class="regexp">          #    root           html;</span></span><br><span class="line"><span class="regexp">          #    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line"><span class="regexp">          #    fastcgi_index  index.php;</span></span><br><span class="line"><span class="regexp">          #    fastcgi_param  SCRIPT_FILENAME  /scripts</span>$fastcgi_script_name;</span><br><span class="line">          <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">          <span class="comment">#&#125;</span></span><br><span class="line">  </span><br><span class="line">          <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">          <span class="comment"># concurs with nginx's one</span></span><br><span class="line">          <span class="comment">#</span></span><br><span class="line">          <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">          <span class="comment">#    deny  all;</span></span><br><span class="line">          <span class="comment">#&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="comment">#server &#123;</span></span><br><span class="line">      <span class="comment">#    listen       8000;</span></span><br><span class="line">      <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">      <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">#    location / &#123;</span></span><br><span class="line">      <span class="comment">#        root   html;</span></span><br><span class="line">      <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">      <span class="comment">#    &#125;</span></span><br><span class="line">      <span class="comment">#&#125;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      <span class="comment"># HTTPS server</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="comment">#server &#123;</span></span><br><span class="line">      <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">      <span class="comment">#    server_name  localhost;</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">     <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">     <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">     <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">#    location / &#123;</span></span><br><span class="line">     <span class="comment">#        root   html;</span></span><br><span class="line">     <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">     <span class="comment">#    &#125;</span></span><br><span class="line">     <span class="comment">#&#125;</span></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>我们知道，在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。</p>
<p>代理简单来说，就是如果我们想做什么，但又不想直接去做，那么这时候就找另外一个人帮我们去做。那么这里有个很典型的例子：在我们平时看的电影里面有雇杀手情节，杀手就是给我们做代理服务的，我们委托杀手去帮我们找到想要杀掉的人，我们只需要给杀手提供佣金就行，并不要我们去杀人。</p>
<p>　　Nginx 主要能够代理如下几种协议，其中用到的最多的就是做Http代理服务器。<img src="/2020/03/31/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/01.jpg"></p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>现在国内是访问不了 Google的，我们一般都是通过科学上网购买别人的服务器梯子或者自己买服务器搭梯子，我们又想为什么通过这种方式就可以上网呢？VPN 就是这样产生的。我们在访问 Google 时，先连上 VPN 服务器将我们的电脑的对外公网 IP 地址能变成美国的公网 IP 地址，然后就可以顺利的访问了。</p>
<p>　这里的 VPN 就是做正向代理的。正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。</p>
<p>PS：这里介绍一下什么是 VPN，VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机，你可以把它理解为一个类似于路由器一样的东西。这样做有什么好处呢？比如 VPN 游戏加速方面的原理，我们要玩网通区的，但是本机接入的是电信的宽带，玩网通区的会比较卡，这时候就利用 VPN 将电信网络变为网通网络，然后在玩网通区的时候就不会卡了（注意：VPN 是不能增加带宽的，不要以为不卡了是因为网速提升了）。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理和正向代理的区别就是：<strong>正向代理代理客户端，反向代理代理服务器。</strong></p>
<p>　　反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>
<p>　　下面我们通过两张图来对比正向代理和方向代理：</p>
<img src="/2020/03/31/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/02.jpg">

<img src="/2020/03/31/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/03.jpg">

<p>理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。</p>
<p>　　总结起来还是上面区别的那句话：<strong>正向代理代理客户端，反向代理代理服务器。</strong></p>
<p>我们可以通过Tomcat来做一个小例子，加深对反向代理的理解</p>
<p>1、启动一个Tomcat 浏览器输入 127.0.0.1:8080 会出现Tomcat的启动成功界面</p>
<img src="/2020/03/31/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/04.jpg">

<p>2、通过修改本地host文件，将<a href="http://www.123.com映射到" target="_blank" rel="noopener">www.123.com映射到</a> 127.0.0.1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 www.123.com</span><br></pre></td></tr></table></figure>

<p>将这段代码添加到本地的host文件最下面</p>
<img src="/2020/03/31/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/05.jpg">

<p>配置完成之后，我们便可以通过 <a href="http://www.123.com:8080" target="_blank" rel="noopener">www.123.com:8080</a> 访问到第一步出现的 Tomcat初始界面。</p>
<p>那么我想只需要输入 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 便可以跳转到 Tomcat初始界面呢？这里便可以用到 nginx的反向代理。在Nginx中配置<a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 并监听80 端口</p>
<p>找到 nginx.conf 配置文件 ，添加下面这段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.123.com;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">            index  index.html index.htm index.jsp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>监听80端口，访问域名为<a href="http://www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。">www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。</a></p>
<p>启动 nginx后，我们在浏览器端输入 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 结果如下：</p>
<img src="/2020/03/31/Nginx%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/06.jpg">

<p>原先我们是通过修改 本地host文件 并访问的是8080 端口，通过nginx代理之后，监听80端口也可以访问了。</p>
<h4 id="Nginx反向代理相关指令介绍"><a href="#Nginx反向代理相关指令介绍" class="headerlink" title="Nginx反向代理相关指令介绍"></a>Nginx反向代理相关指令介绍</h4><h5 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h5><p>配置网络监听</p>
<p>   1）、配置监听的IP地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen address[:port] [default_server] [setfib&#x3D;number] </span><br><span class="line">              [backlog&#x3D;number] [rcvbuf&#x3D;size] [sndbuf&#x3D;size] [deferred]</span><br><span class="line">              [accept_filter&#x3D;filter] [bind] [ssl];</span><br></pre></td></tr></table></figure>

<p>​    2）、配置监听端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen port[default_server] [setfib&#x3D;number] [backlog&#x3D;number] </span><br><span class="line">           [rcvbuf&#x3D;size] [sndbuf&#x3D;size] [accept_filter&#x3D;filter] </span><br><span class="line">           [deferred] [bind] [ipv6only&#x3D;on|off] [ssl];</span><br></pre></td></tr></table></figure>

<p>   3）、配置 UNIX Domain Socket</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen unix:path [default_server]  [backlog&#x3D;number] [rcvbuf&#x3D;size] </span><br><span class="line">                 [sndbuf&#x3D;size] [accept_filter&#x3D;filter] [deferred] [bind] [ssl];</span><br></pre></td></tr></table></figure>

<p>看起来有点复杂，实际使用其实很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen *:80 | *:8080      #监听所有80端口和8080端口</span><br><span class="line">listen  IP_address:port   #监听指定的地址和端口号</span><br><span class="line">listen  IP_address        #监听指定ip地址所有端口</span><br><span class="line">listen port               #监听该端口的所有IP连接</span><br></pre></td></tr></table></figure>

<p>上面各个选项所表示的具体含义</p>
<p>​       1、address:IP地址，如果是 IPV6地址，需要使用中括号[] 括起来，比如[fe80::1]等。</p>
<p>　　2、port:端口号，如果只定义了IP地址，没有定义端口号，那么就使用80端口。</p>
<p>　　3、path:socket文件路径，如 var/run/nginx.sock等。</p>
<p>　　4、default_server:标识符，将此虚拟主机设置为 address:port 的默认主机。（在 nginx-0.8.21 之前使用的是 default 指令）</p>
<p>　　5、 setfib=number:Nginx-0.8.44 中使用这个变量监听 socket 关联路由表，目前只对 FreeBSD 起作用，不常用。</p>
<p>　　6、backlog=number:设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在 FreeBSD 中默认为 -1,其他平台默认为511.</p>
<p>　　7、rcvbuf=size:设置监听socket接收缓存区大小。</p>
<p>　　8、sndbuf=size:设置监听socket发送缓存区大小。</p>
<p>　　9、deferred:标识符，将accept()设置为Deferred模式。</p>
<p>　　10、accept_filter=filter:设置监听端口对所有请求进行过滤，被过滤的内容不能被接收和处理，本指令只在 FreeBSD 和 NetBSD 5.0+ 平台下有效。filter 可以设置为 dataready 或 httpready 。</p>
<p>　　11、bind:标识符，使用独立的bind() 处理此address:port，一般情况下，对于端口相同而IP地址不同的多个连接，Nginx 服务器将只使用一个监听指令，并使用 bind() 处理端口相同的所有连接。</p>
<p>　　12、ssl:标识符，设置会话连接使用 SSL模式进行，此标识符和Nginx服务器提供的 HTTPS 服务有关。</p>
<h5 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h5><p>配置虚拟主机，但是通常分为两种</p>
<p>1、基于名称的虚拟主机配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name name ...;</span><br></pre></td></tr></table></figure>

<p>​       1）、对于name来说，可以只有一个名称，也可以有多个名称，中间用空格隔开。而每个名字由两端或者三段组成，每段之间用“.”隔开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name 123.com www.123.com</span><br></pre></td></tr></table></figure>

<p>​        2）、可以使用通配符 “ * “ ，但通配符只能用在由三段字符组成的首段或者尾段，或者由两段字符组成的尾段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name  *.123.com  www.123.*</span><br></pre></td></tr></table></figure>

<p>​        3）、还可以使用正则表达式，用  “ ~ “ 作为正则表达式字符串的开始标记。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name ~^www\d+\.123\.com$;</span><br></pre></td></tr></table></figure>

<p> 　该表达式“<del>”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0</del>9之间的数字，在紧跟“.123.co”，最后跟着“m”($表示结尾)</p>
<p>　　以上匹配的顺序优先级如下：<br>        ①  准确匹配 server_name<br>        ②  通配符在开始时匹配  server_name<br>        ③  通配符在结尾时匹配  server_name<br>        ④  正则表达式匹配   server_name </p>
<p>2、基于IP地址的虚拟主机配置</p>
<p>语法结构和基于域名匹配一样，而且不需要考虑通配符和正则表达式的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name 192.168.1.1</span><br></pre></td></tr></table></figure>

<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><p>用于匹配URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~] uri &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　   1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p>
<p>　　2、~：用于表示 uri 包含正则表达式，并且区分大小写。</p>
<p>　　3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。</p>
<p>　　4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</p>
<p>　　<strong>注意</strong>：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</p>
<h5 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h5><p>用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_pass URL;</span><br></pre></td></tr></table></figure>

<p>URL 为被代理服务器的地址，可以包含传输协议、主机名称或IP地址加端口号，URI等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_pass  http:&#x2F;&#x2F;www.123.com&#x2F;uri;</span><br></pre></td></tr></table></figure>

<h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>用于设置网站的默认首页。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index file_name ...;</span><br></pre></td></tr></table></figure>

<p>　　后面的文件名称可以有多个，中间用空格隔开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index  index.html index_02.html;</span><br></pre></td></tr></table></figure>

<p>通常这个指令有两个作用：第一个是用户在请求访问网站时，请求地址可以不写首页名称；第二个是可以对一个请求，根据请求内容而设置不同的首页。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化笔记（一）</title>
    <url>/2020/03/19/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><strong>前言：</strong>翻到以前的一些文章笔记，整理了一下，打算写点东西到新搭的Blog上，刚好最近复习了SQL优化方面的知识，于是撸起袖子就码吧，奥利给💪</p>
<a id="more"></a>

<p>MySql性能</p>
<ol>
<li><ul>
<li>最大数据量</li>
<li>最大并发数</li>
<li>查询耗时0.5秒</li>
<li>实施原则</li>
</ul>
</li>
<li><p>数据表设计</p>
<ul>
<li>数据类型</li>
<li>避免空值</li>
<li>text类型</li>
</ul>
</li>
<li><p>索引优化</p>
<ul>
<li>索引分类</li>
<li>优化原则</li>
</ul>
</li>
<li><p>SQL优化</p>
<ul>
<li><p>分批处理</p>
</li>
<li><p>不做列运算</p>
</li>
<li><p>避免Select *</p>
</li>
<li><p>操作符 &lt; &gt; 优化</p>
</li>
<li><p>OR优化</p>
</li>
<li><p>IN 优化</p>
</li>
<li><p>LIKE 优化</p>
</li>
<li><p>JOIN 优化</p>
</li>
<li><p>LinMIT 优化</p>
</li>
</ul>
</li>
</ol>
<h3 id="最大数据量"><a href="#最大数据量" class="headerlink" title="最大数据量"></a>最大数据量</h3><p>MySql没有限制单表的最大记录数，它取决于操作系统对文件大小的限制。<br><img src="/2020/03/19/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/01.jpg" alt="01"></p>
<p>《阿里巴巴Java开发手册》提出单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。性能由综合因素决定，抛开业务复杂度，影响程度依次是硬件配置、MySQL配置、数据表设计、索引优化。500万这个值仅供参考，并非铁律。</p>
<h3 id="最大并发数"><a href="#最大并发数" class="headerlink" title="最大并发数"></a><strong>最大并发数</strong></h3><p>并发数是指同一时刻数据库能处理多少个请求，由max_connections和max_user_connections决定。max_connections是指MySQL实例的最大连接数，上限值是16384，max_user_connections是指每个数据库用户的最大连接数。</p>
<p>MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max_used_connections &#x2F; max_connections * 100% &#x3D; 3&#x2F;100 *100% ≈ 3%</span><br></pre></td></tr></table></figure>

<p>查看最大连接数与响应最大连接数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%max_connections%&#39;;</span><br><span class="line">show variables like &#39;%max_user_connections%&#39;;</span><br></pre></td></tr></table></figure>

<p>在配置文件my.cnf中修改最大连接数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">max_connections &#x3D; 100</span><br><span class="line">max_used_connections &#x3D; 20</span><br></pre></td></tr></table></figure>

<h3 id="查询耗时0-5秒"><a href="#查询耗时0-5秒" class="headerlink" title="查询耗时0.5秒"></a><strong>查询耗时0.5秒</strong></h3><p>建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间。</p>
<h3 id="实施原则"><a href="#实施原则" class="headerlink" title="实施原则"></a><strong>实施原则</strong></h3><p>相比NoSQL数据库，MySQL是个娇气脆弱的家伙。它就像体育课上的女同学，一点纠纷就和同学闹别扭(扩容难)，跑两步就气喘吁吁(容量小并发低)，常常身体不适要请假(SQL约束太多)。如今大家都会搞点分布式，应用程序扩容比数据库要容易得多，所以实施原则是<strong>数据库少干活，应用程序多干活</strong>。</p>
<ul>
<li>充分利用但不滥用索引，须知索引也消耗磁盘和CPU。</li>
<li>不推荐使用数据库函数格式化数据，交给应用程序处理。</li>
<li>不推荐使用外键约束，用应用程序保证数据准确性。</li>
<li>写多读少的场景，不推荐使用唯一索引，用应用程序保证唯一性。</li>
<li>适当冗余字段，尝试创建中间表，用应用程序计算中间结果，用空间换时间。</li>
<li>不允许执行极度耗时的事务，配合应用程序拆分成更小的事务。</li>
<li>预估重要数据表（比如订单表）的负载和数据增长态势，提前优化。</li>
</ul>
<h3 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a><strong>数据表设计</strong></h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h4><p>数据类型的选择原则：更简单或者占用空间更小。</p>
<ul>
<li>如果长度能够满足，整型尽量使用tinyint、smallint、medium_int而非int。</li>
<li>如果字符串长度确定，采用char类型。</li>
<li>如果varchar能够满足，不采用text类型。</li>
<li>精度要求较高的使用decimal类型，也可以使用BIGINT，比如精确两位小数就乘以100后保存。</li>
<li>尽量采用timestamp而非datetime。</li>
</ul>
<p><img src="/2020/03/19/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/02.jpg" alt="02"></p>
<p>相比datetime，timestamp占用更少的空间，以UTC的格式储存自动转换时区。</p>
<h4 id="避免空值"><a href="#避免空值" class="headerlink" title="避免空值"></a><strong>避免空值</strong></h4><p>MySQL中字段为NULL时依然占用空间，会使索引、索引统计更加复杂。从NULL值更新到非NULL无法做到原地更新，容易发生索引分裂影响性能。尽可能将NULL值用有意义的值代替，也能避免SQL语句里面包含is not null的判断。</p>
<h4 id="text类型优化"><a href="#text类型优化" class="headerlink" title="text类型优化"></a><strong>text类型优化</strong></h4><p>由于text字段储存大量数据，表容量会很早涨上去，影响其他字段的查询性能。建议抽取出来放在子表里，用业务主键关联。</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul>
<li>普通索引：最基本的索引。</li>
<li>组合索引：多个字段上建立的索引，能够加速复合查询条件的检索。</li>
<li>唯一索引：与普通索引类似，但索引列的值必须唯一，允许有空值。</li>
<li>组合唯一索引：列值的组合必须唯一。</li>
<li>主键索引：特殊的唯一索引，用于唯一标识数据表中的某一条记录，不允许有空值，一般用primary key约束。</li>
<li>全文索引：用于海量文本的查询，MySQL5.6之后的InnoDB和MyISAM均支持全文索引。由于查询精度以及扩展性不佳，更多的企业选择Elasticsearch。</li>
</ul>
<h4 id="索引优化-1"><a href="#索引优化-1" class="headerlink" title="索引优化"></a>索引优化</h4><ul>
<li>分页查询很重要，如果查询数据量超过30%，MYSQL不会使用索引。</li>
<li>单表索引数不超过5个、单个索引字段数不超过5个。</li>
<li>字符串可使用前缀索引，前缀长度控制在5-8个字符。</li>
<li>字段唯一性太低，增加索引没有意义，如：是否删除、性别。</li>
</ul>
<p>合理使用覆盖索引，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select login_name, nick_name from member where login_name &#x3D; ?</span><br></pre></td></tr></table></figure>

<p>login_name, nick_name两个字段建立组合索引，比login_name简单索引要更快。</p>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h3><h4 id="分批处理"><a href="#分批处理" class="headerlink" title="分批处理"></a><strong>分批处理</strong></h4><p>小时候看到鱼塘挖开小口子放水，水面有各种漂浮物。浮萍和树叶总能顺利通过出水口，而树枝会挡住其他物体通过，有时还会卡住，需要人工清理。MySQL就是鱼塘，最大并发数和网络带宽就是出水口，用户SQL就是漂浮物。</p>
<p>不带分页参数的查询或者影响大量数据的update和delete操作，都是树枝，我们要把它打散分批处理，举例说明：</p>
<p>业务描述：更新用户所有已过期的优惠券为不可用状态。</p>
<p>SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update status&#x3D;0 FROM &#96;coupon&#96; WHERE expire_date &lt;&#x3D; #&#123;currentDate&#125; and status&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>如果大量优惠券需要更新为不可用状态，执行这条SQL可能会堵死其他SQL，分批处理伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pageNo &#x3D; 1;</span><br><span class="line">int PAGE_SIZE &#x3D; 100;</span><br><span class="line">while(true) &#123;</span><br><span class="line">    List&lt;Integer&gt; batchIdList &#x3D; queryList(&#39;select id FROM &#96;coupon&#96; WHERE expire_date &lt;&#x3D; #&#123;currentDate&#125; and status &#x3D; 1 limit #&#123;(pageNo-1) * PAGE_SIZE&#125;,#&#123;PAGE_SIZE&#125;&#39;);</span><br><span class="line">    if (CollectionUtils.isEmpty(batchIdList)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    update(&#39;update status &#x3D; 0 FROM &#96;coupon&#96; where status &#x3D; 1 and id in #&#123;batchIdList&#125;&#39;)</span><br><span class="line">    pageNo ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作符优化"><a href="#操作符优化" class="headerlink" title="操作符优化"></a>操作符优化</h4><p>通常&lt;&gt;操作符无法使用索引，举例如下，查询金额不为100元的订单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from orders where amount !&#x3D; 100;</span><br></pre></td></tr></table></figure>

<p>如果金额为100的订单极少，这种数据分布严重不均的情况下，有可能使用索引。鉴于这种不确定性，采用union聚合搜索结果，改写方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(select id from orders where amount &gt; 100)</span><br><span class="line"> union all</span><br><span class="line">(select id from orders where amount &lt; 100 and amount &gt; 0)</span><br></pre></td></tr></table></figure>

<h4 id="OR优化"><a href="#OR优化" class="headerlink" title="OR优化"></a><strong>OR优化</strong></h4><p>在Innodb引擎下or无法使用组合索引，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id，product_name from orders where mobile_no &#x3D; &#39;13421800407&#39; or user_id &#x3D; 100;</span><br></pre></td></tr></table></figure>

<p>OR无法命中mobile_no + user_id的组合索引，可采用union，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(select id，product_name from orders where mobile_no &#x3D; &#39;13421800407&#39;)</span><br><span class="line"> union</span><br><span class="line">(select id，product_name from orders where user_id &#x3D; 100);</span><br></pre></td></tr></table></figure>

<p>此时id和product_name字段都有索引，查询才最高效。</p>
<p><strong>IN优化</strong></p>
<p>IN适合主表大子表小，EXIST适合主表小子表大。由于查询优化器的不断升级，很多场景这两者性能差不多一样了。</p>
<p>尝试改为join查询，举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from orders where user_id in (select id from user where level &#x3D; &#39;VIP&#39;);</span><br></pre></td></tr></table></figure>

<p>采用JOIN如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select o.id from orders o left join user u on o.user_id &#x3D; u.id where u.level &#x3D; &#39;VIP&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="不做列运算"><a href="#不做列运算" class="headerlink" title="不做列运算"></a>不做列运算</h4><p>通常在查询条件列运算会导致索引失效，如下所示：</p>
<p>查询当日订单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from order where date_format(create_time，&#39;%Y-%m-%d&#39;) &#x3D; &#39;2019-07-01&#39;;</span><br></pre></td></tr></table></figure>

<p>date_format函数会导致这个查询无法使用索引，改写后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from order where create_time between &#39;2019-07-01 00:00:00&#39; and &#39;2019-07-01 23:59:59&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="避免Select-all"><a href="#避免Select-all" class="headerlink" title="避免Select all"></a><strong>避免Select all</strong></h4><p>如果不查询表中所有的列，避免使用SELECT *，它会进行全表扫描，不能有效利用索引。</p>
<h4 id="Like优化"><a href="#Like优化" class="headerlink" title="Like优化"></a><strong>Like优化</strong></h4><p>like用于模糊查询，举个例子（field已建立索引）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT column FROM table WHERE field like &#39;%keyword%&#39;;</span><br></pre></td></tr></table></figure>

<p>这个查询未命中索引，换成下面的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT column FROM table WHERE field like &#39;keyword%&#39;;</span><br></pre></td></tr></table></figure>

<p>去除了前面的%查询将会命中索引，但是产品经理一定要前后模糊匹配呢？全文索引fulltext可以尝试一下，但Elasticsearch才是终极武器。</p>
<h4 id="Join优化"><a href="#Join优化" class="headerlink" title="Join优化"></a><strong>Join优化</strong></h4><p>join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环数据，再次到后一个表中查询数据。</p>
<p>驱动表和被驱动表尽可能增加查询条件，满足ON的条件而少用Where，用小结果集驱动大结果集。<br>被驱动表的join字段上加上索引，无法建立索引的时候，设置足够的Join Buffer Size。<br>禁止join连接三个以上的表，尝试增加冗余字段。</p>
<p><strong>Limit优化</strong></p>
<p>limit用于分页查询时越往后翻性能越差，解决的原则：缩小扫描范围，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from orders order by id desc limit 100000,10</span><br></pre></td></tr></table></figure>

<p>耗时0.4秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from orders order by id desc limit 1000000,10</span><br></pre></td></tr></table></figure>

<p>耗时5.2秒</p>
<p>先筛选出ID缩小查询范围，写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from orders </span><br><span class="line">where id &gt; (select id from orders order by id desc  limit 1000000, 1) </span><br><span class="line">order by id desc </span><br><span class="line">limit 0,10</span><br></pre></td></tr></table></figure>

<p>耗时0.3秒</p>
<p>如果以上方案依然很慢呢？只好用游标了，感兴趣的朋友阅读JDBC使用游标实现分页查询的方法</p>
<h3 id="其他数据库"><a href="#其他数据库" class="headerlink" title="其他数据库"></a>其他数据库</h3><p>作为一名后端开发人员，务必精通作为存储核心的MySQL或SQL Server，也要积极关注NoSQL数据库，他们已经足够成熟并被广泛采用，能解决特定场景下的性能瓶颈。</p>
<p><img src="/2020/03/19/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/03.jpg" alt="03"></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化（三）</title>
    <url>/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="执行计划（重要）"><a href="#执行计划（重要）" class="headerlink" title="执行计划（重要）"></a>执行计划（重要）</h2><h3 id="什么是执行计划？"><a href="#什么是执行计划？" class="headerlink" title="什么是执行计划？"></a><strong>什么是执行计划？</strong></h3><p>一般开发者优化一条SQL语句的第一步执行方案。<br>执行计划的语法： Explain 查询语句</p>
<h3 id="相关字段"><a href="#相关字段" class="headerlink" title="*相关字段 *"></a>*<em>相关字段 *</em></h3><p><strong>id(重要)：标识SQL语句的执行顺序</strong><br>id相同的情况 - 执行顺序从上到下<br>id不同的情况 - id值越大优先级越高<br>id相同、不同都存在的情况 - id值越大优先级越高，相同从上往下<br>id为null的情况 - 永远是最后执行</p>
<a id="more"></a>
<p><strong>select_type: 表示当前查询部分的查询类型</strong><br><strong>SQL语句的分类：</strong>简单查询、复杂查询<br><strong>简单查询</strong> - 不包含子查询、union关键字的SQL语句<br><strong>复杂查询</strong> - 包含子查询（select/where后面包含子查询、from后面包含子查询）、union关键字的SQL语句<br><strong>可选值：</strong><br><strong>SIMPLE</strong>:查询中不包含任何子查询或者union </p>
<p><strong>PRIMARY</strong>:查询中包含了任何复杂的子部分，最外层的就会变成PRIMARY （最后被执行的查询） </p>
<p><strong>SUBQUERY</strong>:在SELECT或者WHERE列表中的子查询标记为SUBQUERY   </p>
<p><strong>DERIVED</strong>：在FROM中包含的子查询被标记为 DERIVED（衍生表）   </p>
<p><strong>UNION</strong>:如果第二个SELECT出现在UNION之后，则被标记为UNION，如果UNION包含在FROM子句的子查询中，第一个SELECT会被标记为：DERIVED</p>
<p><strong>UNION RESULT</strong>：从UNION表获取结果的select</p>
<p><strong>table：操作的表名</strong></p>
<p><strong>type（重要）：表示MySQL会用什么方式去表中获取数据行</strong><br><strong>可选值：</strong>  </p>
<p>all - 全表扫描，效率最低 </p>
<p>index - 全索引扫描，效率比全表略好    </p>
<p>range - 索引范围扫描，只扫描了部分索引 </p>
<p> ref - 出现在非唯一性索引，表示只需要扫描精准值的局部范围  </p>
<p>eq_ref - 出现在唯一性索引的连接查询中  </p>
<p>const - 直接操作主键查询时出现，表示系统将当前的查询变成了一个常量  </p>
<p>system - 表示系统明确的知道表中一定只有一条记录  </p>
<p>null - 表示SQL语句直接在编译时获得结果</p>
<p><strong>possible_keys：可以用上的索引，不一定用上</strong></p>
<p><strong>keys（重要）：当前执行计划用上的索引</strong><br><strong>注意：</strong><br>有可能出现  possible_keys  没有的索引，但是keys中出现了，也有可能出现possible_keys有索引，但是keys为null</p>
<p><strong>key_len：</strong>表示使用的索引长度，这个值越大，表示索引的使用效率越高</p>
<p><strong>rows(重要)：</strong>表示查询结果可能需要扫描的记录行数，这个地方的值越小越好</p>
<p><strong>Extra（重要）：表示执行过程中的一些额外信息</strong><br>     Using index - 表示使用了<strong>覆盖索引</strong>  </p>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><p>SQL语句的正常编写顺序：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">   &lt; Select_list &gt;</span><br><span class="line">FROM</span><br><span class="line">   &lt; Left_table &gt; &lt; Join_type &gt;</span><br><span class="line">Join &lt; Right_table &gt; ON &lt; Join_condition &gt;</span><br><span class="line">WHERE</span><br><span class="line">   &lt; Where_condition &gt;</span><br><span class="line">GROUP BY</span><br><span class="line">   &lt; group_by_list &gt;</span><br><span class="line">HAVING</span><br><span class="line">   &lt; having_condition &gt;</span><br><span class="line">ORDER By</span><br><span class="line">   &lt; order_by_condition &gt;</span><br><span class="line">LIMIT &lt; limit_number &gt;</span><br></pre></td></tr></table></figure>

<p>SQL语句的执行顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FROM &lt;Left_table&gt;</span><br><span class="line">ON &lt;Join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">WHERE &lt;where_condition&gt;</span><br><span class="line">GROUP BY &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<p>SQL的执行过程<br><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/01.png"></p>
<h2 id="慢查询日志："><a href="#慢查询日志：" class="headerlink" title="慢查询日志："></a>慢查询日志：</h2><h3 id="什么是慢查询日志？"><a href="#什么是慢查询日志？" class="headerlink" title="什么是慢查询日志？"></a>什么是慢查询日志？</h3><p> 专门用来记录查询较慢的SQL语句的日志。MySQL自动有一个阈值的设定（默认为10S），一旦查询语句超过阈值，就会被慢查询日志记录下来。</p>
<p>慢查询日志默认是关闭的，为了节省性能。</p>
<p>*<em>慢查询日志的相关命令   : *</em><br>select @@slow_query_log; - 查询慢查询日志是否开启 0 - 未开启 1 - 开启   </p>
<p>set global slow_query_log = 1; - 临时开启慢查询日志，mysql服务重启又会关闭   </p>
<p>show variables like ‘long%’; - 查看慢查询的阈值，默认10S   </p>
<p>set long_query_time=0.0001; - 设置慢查询日志的阈值   </p>
<p>select @@slow_query_log_file; - 查看慢查询日志的位置</p>
<h3 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h3><p><strong>什么是show profile?</strong>  - </p>
<p>是一个实时的SQL语句执行诊断工具</p>
<p><strong>相关命令：</strong>   </p>
<p>show variables like ‘profiling’;   – 查看profile功能是否打开   </p>
<p>set profiling = on;                      –  临时开启profile功能   </p>
<p>show profiles;                            –  查看刚刚执行过的sql语句的执行时间和查询id号   </p>
<p>show profile cpu for query_ID;   – 根据id诊断sql语句</p>
<img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/02.png">

<p>根据 query_ID 诊断执行SQL语句</p>
<img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/03.png">

<h4 id="关闭MySQL自带的查询缓存"><a href="#关闭MySQL自带的查询缓存" class="headerlink" title="关闭MySQL自带的查询缓存"></a>关闭MySQL自带的查询缓存</h4><p>show variables like “%cache%”;<br>set query_cache_type=OFF;<br>set global query_cache_size=0;</p>
<img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/04.jpg">

<h4 id="查询优化示例："><a href="#查询优化示例：" class="headerlink" title="查询优化示例："></a>查询优化示例：</h4><p>首先准备 :<br>学生表  : 20W<br><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/05.jpg"></p>
<p>课程表 : 67W<br><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/06.jpg"></p>
<p>这里大批量的数据插入 我一般都是写存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 学生表插入大批量的数据</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_stu;  <span class="comment">--删除一个 insert_stu 的存储过程，如果存在就删除</span></span><br><span class="line">delimiter &amp;&amp;  <span class="comment">-- 声明结束符</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_stu() <span class="comment">-- 创建一个存储过程</span></span><br><span class="line"><span class="keyword">begin</span>  <span class="comment">-- 开始</span></span><br><span class="line">    <span class="comment">-- declare 是mysql存储过程中声明一个变量的命令</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>; <span class="comment">-- 声明一个 int 类型的 i，默认是 0   </span></span><br><span class="line">     <span class="comment">-- Mysql中没有 for 循环</span></span><br><span class="line">    A:loop  <span class="comment">-- 开始loop循环 ，并给了一个别名 A</span></span><br><span class="line">         <span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="literal">null</span>,<span class="keyword">concat</span>(<span class="string">"小明"</span>,i),i,<span class="keyword">rand</span>(),<span class="keyword">now</span>(),<span class="keyword">rand</span>()*<span class="number">20</span>); </span><br><span class="line">         <span class="comment">-- concat() 函数是拼接函数 这里是将 "小明" 和 i 拼接 ,</span></span><br><span class="line">         <span class="comment">-- rand() 是随机数 ,</span></span><br><span class="line">         <span class="comment">-- now() 是当前时间 ,</span></span><br><span class="line">         <span class="comment">-- rand()*20 随机数乘以20</span></span><br><span class="line">         <span class="keyword">set</span> i = i + <span class="number">1</span>;</span><br><span class="line">         if i &gt;= 200000 then</span><br><span class="line">            leave A ; <span class="comment">-- loop循环没有循环条件 条件是 用 leave 离开它</span></span><br><span class="line">         <span class="keyword">end</span> <span class="keyword">if</span> ; <span class="comment">-- 结束 if 判断</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>; <span class="comment">-- 结束loop循环</span></span><br><span class="line"><span class="keyword">end</span> &amp;&amp; <span class="comment">-- 结束</span></span><br><span class="line">delimiter ; <span class="comment">-- 再把结束符设置为分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">call</span> insert_stu();</span><br></pre></td></tr></table></figure>

<p><strong>但是!!!!</strong>执行这个存储过程需要20分钟左右时间…，这里跟电脑性能有关，或者用java批处理执行效率会更高一些</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#批量插入学生成绩</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_score;</span><br><span class="line">delimiter &amp;&amp;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_score()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>; <span class="comment">-- 学生</span></span><br><span class="line">  <span class="keyword">declare</span> j <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>; <span class="comment">-- 当前课程的 id</span></span><br><span class="line">    A:loop </span><br><span class="line">      <span class="keyword">set</span> j= <span class="keyword">rand</span>() * <span class="number">20</span> + <span class="number">1</span>; <span class="comment">-- 随机二十门课（具体看表设计）</span></span><br><span class="line">      B:loop </span><br><span class="line">         <span class="keyword">insert</span> <span class="keyword">into</span> score <span class="keyword">value</span>(i, j, <span class="keyword">rand</span>() * <span class="number">100</span>); <span class="comment">-- 学生，课程，随机分数</span></span><br><span class="line">         <span class="keyword">set</span> j= j + <span class="keyword">rand</span>() * <span class="number">5</span> + <span class="number">1</span>; <span class="comment">-- 下一门课</span></span><br><span class="line">         if j&gt; 20 then -- 如果这门课大于 20</span><br><span class="line">               leave B; <span class="comment">-- 跳出循环</span></span><br><span class="line">         <span class="keyword">end</span> <span class="keyword">if</span> ;</span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">loop</span> B ;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">set</span> i= i + <span class="number">1</span> ;  <span class="comment">-- 执行这个循环</span></span><br><span class="line">      if i &gt; 200000 then  -- </span><br><span class="line">              leave A;</span><br><span class="line">		<span class="keyword">end</span> <span class="keyword">if</span> ;</span><br><span class="line">     <span class="keyword">end</span> <span class="keyword">loop</span> A;</span><br><span class="line"><span class="keyword">end</span> &amp;&amp; </span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> insert_score();</span><br></pre></td></tr></table></figure>

<p>准备好数据后</p>
<p>1、查询成绩表的总条数<img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/07.jpg"></p>
<p>走执行计划看下耗时<br><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/08.jpg"></p>
<p><strong>模糊查询的优化</strong><br><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/09.jpg"></p>
<p>1、优化方式一 ： 使用覆盖索引，不走回表了<br>    1)、创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_student <span class="keyword">on</span> student(<span class="keyword">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建复合索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_stuname_stuage <span class="keyword">on</span> student(<span class="keyword">name</span>,age);</span><br></pre></td></tr></table></figure>

<p>设置好索引后，sql语句就不能用 select * 来查， 因为走的是全表扫描，可以到 Explain 执行计划里面去看,  Type 属性显示的是 ALL 走的是全表扫描，Key  为空 索引并没有被使用 <img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/10.jpg"></p>
<p>再看这段<br><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/11.jpg"></p>
<p>这里可以看到 possible_keys 这里可用索引为空，但是 key 最后却用上了索引， 查询sql模糊查询 并且还是 % ,这里做的操作就是引用了这个覆盖索引执行查询。</p>
<p>再来看一下执行时间 0.0027s<br><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/12.png"></p>
<p>覆盖索引查询的字段必须在索引里面有，没有的话就用不上覆盖索引了。</p>
<p>那我现在就要做全字段查询呢？<br>这里建议使用全文检索服务 - Lucene:<br>1、Elasticsearch<br>2、Solr</p>
<h3 id="数据库表结构优化"><a href="#数据库表结构优化" class="headerlink" title="数据库表结构优化"></a>数据库表结构优化</h3><img src="/2020/03/28/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89/多数据源处理图.png">

]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化（二）</title>
    <url>/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、MySQL的逻辑架构"><a href="#一、MySQL的逻辑架构" class="headerlink" title="一、MySQL的逻辑架构"></a>一、MySQL的逻辑架构</h2><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/01.png">

<p>第一层：连接处理层（处理客户端的连接，权限验证，身份认证…）</p>
<p>第二层：核心服务层（解析SQL语句，并且进行优化选择，存储过程、函数、视图都是在这一层执行的）</p>
<p>第三层：存储引擎层（提取和存储数据）</p>
<p>第四层：物理磁盘层（硬盘）</p>
<a id="more"></a>

<h2 id="二、MYSQL的存储引擎"><a href="#二、MYSQL的存储引擎" class="headerlink" title="二、MYSQL的存储引擎"></a>二、MYSQL的存储引擎</h2><p>  <strong>MyISAM（MySQL5.5之前，默认的存储引擎）</strong> VS <strong>InnoDB（MySQL5.5之后，包括5.5，默认的存储引擎）</strong></p>
<p><strong>区别：</strong><br> 1、MyISAM不支持事务，InnoDB支持事务<br> 2、MyISAM只有表锁，InnoDB引入了行锁<br> 3、MyISAM不支持外键，InnoDB支持外键<br> 4、MyISAM支持全文索引，InnoDB（5.6以后的版本支持）<br> 5、MyISAM读写数据的速度相对比InnoDB要快</p>
<p><strong>相关命令：</strong><br>show engines; - 查询当前数据库支持的存储引起<br>show variables like ‘%storage_engine%’ - 查询当前默认的存储引擎<br>show table status like ‘表名’ - 查询表的相关信息（存储引擎）</p>
<h2 id="三、数据类型的优化"><a href="#三、数据类型的优化" class="headerlink" title="三、数据类型的优化"></a>三、数据类型的优化</h2><p> 选择合适的数据类型，对数据库的sql优化至关重要，本身合适的数据类型可能只需要更少的空间和计算能力</p>
<p> <strong>如何选择合适的数据类型：</strong><br>     1、选择更小的数据类型<br>     2、选择更合适更简单的数据类型<br>     3、字段尽量避免为null</p>
<p><strong>相关数据类型：</strong></p>
<p><strong>整数型：</strong><br>tinyint - 8位<br>smallint - 16位<br>mediumint - 24位<br>int - 32位<br>bigint - 64位</p>
<p><strong>unsigned属性：</strong>将字段的类型设置为正数，当一个类型不允许为负数时，正数的上限大致会提高1倍，tinyint unsigned（0~255，占1个字节）特别适合存放年龄</p>
<p><strong>注意：int(11)是指定整数类型的宽度，它不会限制值得合法范围，对于存储和计算而言，int(1)和int(20)没什么区别**</strong></p>
<p><strong>浮点型：</strong><br>float - 32位<br>double - 64位<br>decimal - 精准小数</p>
<p><strong>字符串类型：</strong><br>varchar - 可变长字符串，往往只需要使用合适的存储空间来存储数据，但是需要额外的<strong>花费1~2个字节记录数据的实际长度</strong><br>char - 定长字符串，mysql总是根据定义的字符串长度分配足够的空间。<br>blob - 大二进制类型<br>text - 大文本类型</p>
<p><strong>注意：</strong><br> <strong>1、char(1)比varchar(1)的性能要好，因为varchar需要额外的空间存储数据长度</strong><br><strong>2、varchar(20)比varchar(200)的计算性能要高</strong></p>
<p><strong>日期和时间类型：</strong><br>datetime: - 占用8个字节，范围1001<del>9999年<br>timestamp: - 占用4个字节，范围1970</del>2038年，支持时区</p>
<h2 id="四、索引优化（重要）"><a href="#四、索引优化（重要）" class="headerlink" title="四、索引优化（重要）"></a>四、索引优化（重要）</h2><p> <strong>什么是索引？</strong><br>索引就像一本书的目录，可以帮助我们快速的找到相关的数据。（索引是一种用于快速搜索的数据结构）<br>索引是存储引擎用于快速找到记录的一种数据结构。<br>索引对于良好的性能非常关键。<br>尤其当表中的数据量越来越大时，索引对性能的影响越发重要。<br>索引应该是对查询性能优化最有效的手段了。<br>索引能够轻易将查询性能提高几个数量级。<br>但是索引经常被忽略，不恰当的索引对性能可能还会带来负面效果</p>
<h3 id="为什么索引可以快速的定位到数据？"><a href="#为什么索引可以快速的定位到数据？" class="headerlink" title="为什么索引可以快速的定位到数据？"></a>为什么索引可以快速的定位到数据？</h3><p>   <strong>无索引的搜索方式：</strong><br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/02.png"></p>
<p><strong>有索引的搜索方式：</strong><br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/03.png"></p>
<p><strong>什么时候适合添加索引？</strong><br>1、数据量巨大<br>2、字段选择性大的时候<br>3、非null的列<br>4、修改频率低的列<br><strong>什么时候不适合添加索引？</strong><br>1、数据量小<br>2、字段选择性小<br>3、可能存在大量的null值<br>4、修改频率高</p>
<h3 id="索引的相关命令"><a href="#索引的相关命令" class="headerlink" title="索引的相关命令"></a>索引的相关命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单值索引：</span><br><span class="line">create index 索引名称 on 表名(字段名)</span><br><span class="line"></span><br><span class="line">多列索引（复合索引）：</span><br><span class="line">create index 索引名称 on 表名(字段名1, 字段名2.....)</span><br><span class="line"></span><br><span class="line">唯一性索引：</span><br><span class="line">create unique index 索引名称 on 表名(字段名)</span><br><span class="line"></span><br><span class="line">全文索引：</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    1、主键自带索引（性能最好的索引）</span><br><span class="line">    2、除了主键索引，其他所有创建的索引都叫做二级索引    </span><br><span class="line">    3、对于数据库的任意列，可以反复创建索引   </span><br><span class="line">    4、多列索引列的顺序是很重要的 </span><br><span class="line"></span><br><span class="line">#思考：</span><br><span class="line">#index(name,age) 不等同于 index(name)+index(age)</span><br><span class="line">#index(name,age) 不等同于 index(age,name)</span><br></pre></td></tr></table></figure>

<h3 id="索引的底层原理？"><a href="#索引的底层原理？" class="headerlink" title="索引的底层原理？"></a><strong>索引的底层原理？</strong></h3><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a><strong>哈希索引</strong></h4><p><strong>什么是哈希表？</strong>-<br> 是一个快速搜索的数据结构，搜索的时间复杂度O(1)<br><strong>什么是哈希函数？</strong> -<br>将一个任意类型的key，可以转换成一个int类型的下标<br><strong>设计一个哈希函数：</strong><br><strong>1、任何类型的key，都可以转换成int类型</strong><br><strong>2、任意相同的key，每次通过哈希函数转换的值必须相同</strong><br><strong>3、任意的key转换的下标，必须在数组的范围内</strong><br><strong>简单的哈希函数设计：key.hashCode() % length</strong></p>
<p><strong>什么是哈希碰撞？</strong> -<br> 两个不同的key，通过哈希函数算出了相同的下标（哈希碰撞不可避免）<br><strong>解决哈希碰撞的方式：链地址法</strong></p>
<p><strong>什么是填充因子？</strong> - 哈希表的扩容条件，默认值0.75，当元素的数量 ： 数组的长度 &gt;= 填充因子时，就会进行扩容</p>
<h2 id="为什么MySQL不选择哈希表作为索引的实现原理？"><a href="#为什么MySQL不选择哈希表作为索引的实现原理？" class="headerlink" title="为什么MySQL不选择哈希表作为索引的实现原理？"></a><strong>为什么MySQL不选择哈希表作为索引的实现原理？</strong></h2><p>   哈希索引可以用于精准定位，但是不适用于范围查询</p>
<h3 id="为什么MySQL不选择精准定位和范围查询都优秀的红-黑树呢？"><a href="#为什么MySQL不选择精准定位和范围查询都优秀的红-黑树呢？" class="headerlink" title="为什么MySQL不选择精准定位和范围查询都优秀的红-黑树呢？"></a><strong>为什么MySQL不选择精准定位和范围查询都优秀的红-黑树呢？</strong></h3><p>因为当MySQL数据量很大的是否，索引的体积也会很大，可能内存放不下，所以需要从硬盘上进行相关读写，如果树的层级太高，则读写硬盘的次数就会越多，性能就会越差</p>
<h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><p>  <strong>什么是BTree？</strong></p>
<p>就是一颗绝对平衡的多路树<br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/04.png"></p>
<p>  <strong>什么是B+Tree?</strong><br>  和BTree不同点：<br>     1、所有的子节点，一定会出现在叶子节点上<br>     2、相邻的叶子节点之间，会用一个双向链表连接起来<br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/05.png"></p>
<p>数据结构图形化网页：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<p>  <strong>模拟一组数据生成索引数的过程：</strong><br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/06.png"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">为什么会出现索引的失效（创建了一个索引，但是MySQL还是全表扫描）？</span><br><span class="line"></span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"8小明"</span> - 完全可以用上索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> age = <span class="number">18</span>            - 不能用上索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"8小明"</span> <span class="keyword">and</span> age = <span class="number">16</span> - 完美的用上了索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"8小明"</span> <span class="keyword">and</span> age &lt; <span class="number">16</span> - 完美用上索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> &lt; <span class="string">"8小明"</span> <span class="keyword">and</span> age = <span class="number">16</span> - <span class="keyword">name</span>会用上索引，age用不上索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> !=<span class="string">"8小明"</span> - 不能用上索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">"%小明%"</span> - 不能用上索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">"8小%"</span> - 能用上索引</span><br><span class="line">       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"1小黑"</span> <span class="keyword">or</span> age = <span class="number">18</span> - 用不上索引，但是<span class="number">5.6</span></span><br><span class="line">       以后会采用索引合并的方式查询该<span class="keyword">SQL</span> <span class="keyword">index</span>(<span class="keyword">name</span>)  <span class="keyword">index</span>(age)</span><br></pre></td></tr></table></figure>

<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>​     什么是聚簇索引？- MyISAM没有聚簇索引，InnoDB主键索引就是聚簇索引<br>​     聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。<br>​    聚簇索引的叶子节点称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。</p>
<p><strong>非聚簇索引</strong><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/07.png"></p>
<p><strong>聚簇索引</strong><br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/08.png"></p>
<p>  注意：如果InnoDB创建一张没有主键的表，会默认选择一个唯一性索引的字段创建聚簇索引，如果没有唯一性索引的字段就会有一个隐性字段成为聚簇索引</p>
<h3 id="辅助索引（二级索引）"><a href="#辅助索引（二级索引）" class="headerlink" title="辅助索引（二级索引）"></a>辅助索引（二级索引）</h3><p>  非主键索引，叶子节点=键值+书签。Innodb存储引擎的书签就是相应行数据的主键索引值。</p>
<p>操作示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">主键索引:</span><br><span class="line">  创建的时候添加:  </span><br><span class="line">    <span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">      <span class="keyword">Id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">      <span class="keyword">Id</span> <span class="built_in">int</span>,</span><br><span class="line">      Primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">表创建完了之后添加</span><br><span class="line">	<span class="keyword">Alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">删除主键索引:</span><br><span class="line">	<span class="keyword">Alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">唯一索引:</span><br><span class="line">  <span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">  	<span class="keyword">Id</span> <span class="built_in">int</span> <span class="keyword">unique</span>,</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">    <span class="keyword">Id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">Unique</span> <span class="keyword">key</span> uni_name (<span class="keyword">id</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">表创建好之后添加唯一索引:</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> s1 <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">key</span>  u_name(<span class="keyword">id</span>);</span><br><span class="line">删除唯一索引:</span><br><span class="line">	<span class="keyword">Alter</span> <span class="keyword">table</span> s1 <span class="keyword">drop</span> <span class="keyword">index</span> u_name;</span><br><span class="line"></span><br><span class="line">普通索引:</span><br><span class="line">创建:</span><br><span class="line">  <span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">    <span class="keyword">Id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">Index</span> index_name(<span class="keyword">id</span>)</span><br><span class="line">  )</span><br><span class="line">表创建好之后添加普通索引:  </span><br><span class="line">	<span class="keyword">Alter</span> <span class="keyword">table</span> s1 <span class="keyword">add</span> <span class="keyword">index</span> index_name(<span class="keyword">id</span>);</span><br><span class="line">	<span class="keyword">Create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> s1(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line">删除普通索引:</span><br><span class="line">	<span class="keyword">Alter</span> <span class="keyword">table</span> s1 <span class="keyword">drop</span> <span class="keyword">index</span> u_name;</span><br><span class="line">	<span class="keyword">DROP</span> <span class="keyword">INDEX</span> 索引名 <span class="keyword">ON</span> 表名字;</span><br></pre></td></tr></table></figure>

<p>将上面添加索引的字段变为多个就成了联合索引，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">联合主键索引</span><br><span class="line">	<span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">      <span class="keyword">Id</span> <span class="built_in">int</span>,</span><br><span class="line">      <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">      Primary <span class="keyword">key</span>(<span class="keyword">id</span>，<span class="keyword">name</span>)</span><br><span class="line">    )</span><br><span class="line">联合唯一索引</span><br><span class="line">	<span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">    <span class="keyword">Id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">Unique</span> <span class="keyword">key</span> uni_name (<span class="keyword">id</span>，<span class="keyword">name</span>)</span><br><span class="line">  )</span><br><span class="line">联合普通索引</span><br><span class="line">	<span class="keyword">Create</span> <span class="keyword">table</span> t1(</span><br><span class="line">    <span class="keyword">Id</span> <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">Index</span> index_name(<span class="keyword">id</span>，<span class="keyword">name</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">创建表完成之后，再添加联合索引的方式和上面的给单个字段添加索引的方式相同。</span><br></pre></td></tr></table></figure>



<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>什么是覆盖索引？- </p>
<p>解释一：是SQL优化的重要手段之一，有时候还会人为的构造覆盖索引。有时需要查询的结果，直接在索引上可以获得，就不用再回表查询了，就是select的数据列只用从索引中就能够取得，不必从数据表中读取，这种查询方式，就是覆盖索引。</p>
<p>解释二：索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。</p>
<p>解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。</p>
<p>注意：<br>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引</p>
<p>当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在explain(执行计划)的Extra列可以看到“Using index”的信息<br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/09.png"></p>
<p>从执行结果上看，这个SQL语句只通过索引，就取到了所需要的数据，这个过程就叫做索引覆盖。</p>
<h3 id="覆盖索引的几种优化场景"><a href="#覆盖索引的几种优化场景" class="headerlink" title="覆盖索引的几种优化场景"></a>覆盖索引的几种优化场景</h3><h4 id="无-Where-条件的查询优化"><a href="#无-Where-条件的查询优化" class="headerlink" title="无 Where 条件的查询优化"></a>无 Where 条件的查询优化</h4><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/10.png">

<p>执行计划中，type 为ALL，表示进行了全表扫描</p>
<p>如何改进？优化措施很简单，就是对这个查询列建立索引。如下，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ALERT TABLE t1 ADD KEY(staff_id);</span><br></pre></td></tr></table></figure>

<p>再看一下执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sql_no_cache <span class="keyword">count</span>(staff_id) <span class="keyword">from</span> t1</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t1</span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">index</span></span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">          <span class="keyword">key</span>: staff_id</span><br><span class="line">      key_len: <span class="number">1</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1023849</span></span><br><span class="line">　　　　　 Extra: <span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>　<strong>possible_key</strong>: NULL，说明没有WHERE条件时查询优化器无法通过索引检索数据，这里使用了索引的另外一个优点，即从索引中获取数据，减少了读取的数据块的数量。 无<strong>where</strong>条件的查询，可以通过索引来实现索引覆盖查询，但前提条件是，查询返回的字段数足够少，更不用说 <strong>select *</strong> 之类的了。毕竟，建立key length过长的索引，始终不是一件好事情。</p>
<p>查询消耗：<br><img src="/2020/03/21/SQL%E4%BC%98%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/11.png"></p>
<p>这次查询 0.72 sec 的损耗对比上面一次查询损耗0.85 sec  , 从时间上看小了 0.13 sec</p>
<h4 id="二次检索优化"><a href="#二次检索优化" class="headerlink" title="二次检索优化"></a>二次检索优化</h4><p>示例查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_no_cache rental_date <span class="keyword">from</span> t1 <span class="keyword">where</span> inventory_id&lt;<span class="number">100000</span>;</span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line">| 2020-03-27 22:10:05 |</span><br><span class="line">| 2020-03-27 22:11:27 |</span><br><span class="line">| 2020-03-27 22:12:31 |</span><br><span class="line">| 2020-03-27 22:14:00 |</span><br><span class="line">| 2020-03-27 22:16:91 |</span><br><span class="line">| 2020-03-27 22:18:27 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">99999 rows in <span class="keyword">set</span> (<span class="number">0.19</span> sec)</span><br></pre></td></tr></table></figure>

<p>走一遍 Explain执行计划:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sql_no_cache rental_date <span class="keyword">from</span> t1 <span class="keyword">where</span> inventory_id&lt;<span class="number">100000</span>*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t1</span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">range</span></span><br><span class="line">possible_keys: inventory_id</span><br><span class="line">          <span class="keyword">key</span>: inventory_id</span><br><span class="line">      key_len: <span class="number">3</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">175383</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span> condition</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>Extra：</strong> Using index condition 表示使用的索引方式为二级检索，即99999个书签值被用来进行回表查询。可想而知，还是会有一定的性能消耗的</p>
<p>　　尝试针对这个SQL建立联合索引，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">key</span>(inventory_id,rental_date);</span><br></pre></td></tr></table></figure>

<p>在走一遍执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sql_no_cache rental_date <span class="keyword">from</span> t1 <span class="keyword">where</span> inventory_id&lt;<span class="number">80000</span>*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t1</span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">range</span></span><br><span class="line">possible_keys: inventory_id,inventory_id_2</span><br><span class="line">          <span class="keyword">key</span>: inventory_id_2</span><br><span class="line">      key_len: <span class="number">3</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">182884</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"><span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>　　Extra：Using index 表示没有会标查询的过程，实现了索引覆盖</p>
<h4 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h4><p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tid,return_date <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br><span class="line">+<span class="comment">-------+---------------------+</span></span><br><span class="line">| tid   | return_date         |</span><br><span class="line">+<span class="comment">-------+---------------------+</span></span><br><span class="line">| 90001 | 2020-03-27 23:04:36 |</span><br><span class="line">| 90002 | 2020-03-23 03:16:12 |</span><br><span class="line">| 90003 | 2020-03-27 22:41:03 |</span><br><span class="line">| 90004 | 2020-03-23 04:39:28 |</span><br><span class="line">| 90005 | 2020-03-23 04:41:20 |</span><br><span class="line">| 90006 | 2020-03-27 22:54:10 |</span><br><span class="line">| 90007 | 2020-03-23 07:21:51 |</span><br><span class="line">| 90008 | 2020-03-25 21:51:16 |</span><br><span class="line">| 90009 | 2020-03-27 03:44:32 |</span><br><span class="line">| 90010 | 2020-03-23 00:00:34 |</span><br><span class="line">+<span class="comment">-------+---------------------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.75</span> sec)</span><br></pre></td></tr></table></figure>

<p>　　在未优化之前，我们看到它的执行计划是非常糟糕的一个结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> tid,return_date <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t1</span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">          <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">      key_len: <span class="literal">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1023675</span></span><br><span class="line">        </span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>　　看出是全表扫描。加上而外的排序，性能消耗是不低的<br>　　如何通过覆盖索引优化呢？<br>　　我们创建一个索引，包含排序列以及返回列，由于tid是主键字段,<br>       因此，下面的复合索引就包含了tid的字段值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">index</span> index_zhang(inventory_id,return_date);</span><br></pre></td></tr></table></figure>

<p>实际效果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tid,return_date <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</span><br><span class="line">+<span class="comment">-------+---------------------+</span></span><br><span class="line">| tid   | return_date         |</span><br><span class="line">+<span class="comment">-------+---------------------+</span></span><br><span class="line">| 90001 | 2020-03-27 23:04:36 |</span><br><span class="line">| 90002 | 2020-03-23 03:16:12 |</span><br><span class="line">| 90003 | 2020-03-27 22:41:03 |</span><br><span class="line">| 90004 | 2020-03-23 04:39:28 |</span><br><span class="line">| 90005 | 2020-03-23 04:41:20 |</span><br><span class="line">| 90006 | 2020-03-27 22:54:10 |</span><br><span class="line">| 90007 | 2020-03-28 07:21:51 |</span><br><span class="line">| 90008 | 2020-03-25 21:51:16 |</span><br><span class="line">| 90009 | 2020-03-27 03:44:32 |</span><br><span class="line">| 90010 | 2020-03-28 00:00:34 |</span><br><span class="line">+<span class="comment">-------+---------------------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以发现，添加复合索引后，速度提升0.72s<br>我们看一下改进后的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> tid,return_date <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>\G</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t1</span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">index</span></span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">          <span class="keyword">key</span>: liu</span><br><span class="line">      key_len: <span class="number">9</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">90010</span></span><br><span class="line">　　　　Extra: <span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>　执行计划也可以看到，Type: index  使用到了复合索引，并且不需要回表　　<br>   对比一下如下的改写SQL，思想是通过索引消除排序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.tid,a.return_date <span class="keyword">from</span>  t1 a </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">(<span class="keyword">select</span> tid <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> inventory_id <span class="keyword">limit</span> <span class="number">900000</span>,<span class="number">10</span>) b <span class="keyword">on</span> a.tid=b.tid;</span><br></pre></td></tr></table></figure>

<p>　　并在此基础上，我们为inventory_id列创建索引，并删除之前的覆盖索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">index</span> idx_inid(inventory_id)；</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_zhang;</span><br></pre></td></tr></table></figure>

<p>然后收集统计信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select a.tid,a.return_date from t1 a inner join  </span><br><span class="line">(select tid from t1 order by inventory_id limit 900000,10) b on a.tid&#x3D;b.tid;</span><br><span class="line">+--------+---------------------+</span><br><span class="line">| tid    | return_date         |</span><br><span class="line">+--------+---------------------+</span><br><span class="line">| 900001 | 2020-03-23 23:09:34 |</span><br><span class="line">| 900002 | 2020-03-23 10:41:03 |</span><br><span class="line">| 900003 | 2020-03-27 08:10:22 |</span><br><span class="line">| 900004 | 2020-03-23 11:47:23 |</span><br><span class="line">| 900005 | 2020-03-25 21:32:02 |</span><br><span class="line">| 900006 | 2020-03-27 19:55:42 |</span><br><span class="line">| 900007 | 2020-03-27 17:45:55 |</span><br><span class="line">| 900008 | 2020-03-28 01:37:32 |</span><br><span class="line">| 900009 | 2020-03-27 11:38:06 |</span><br><span class="line">| 900010 | 2020-03-23 15:10:57 |</span><br><span class="line">+--------+---------------------+</span><br></pre></td></tr></table></figure>

<p>这种优化手段较前者时间多消耗了大约140ms。这种优化手段虽然使用索引消除了排序，但是还是要通过主键值<strong>回表</strong>查询。<br>因此，在select返回列较少或列宽较小的时候，我们可以通过建立复合索引的方式优化分页查询，效果更佳，主要原因是因为它不需要回表！不需要回表！这个点是很重要的。</p>
<h4 id="建了索引但是查询不走索引"><a href="#建了索引但是查询不走索引" class="headerlink" title="建了索引但是查询不走索引"></a>建了索引但是查询不走索引</h4><p>建表示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tab_person`</span> (</span><br><span class="line"><span class="string">`p_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`p_code`</span> <span class="built_in">char</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`p_amount`</span> <span class="built_in">decimal</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`p_id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uni_p_code`</span> (<span class="string">`p_code`</span>) <span class="keyword">USING</span> BTREE )</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p><strong>查询语句：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> p_code  ,p_amount <span class="keyword">from</span> tab_person <span class="keyword">order</span> <span class="keyword">by</span> p_code <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p> 走一遍 Explain 会发现虽然在  p_code  上建了索引，但是看查询计划却不走索引，为什么呢？<br>  因为数据行读取  p_amount，所以是随机IO。那怎么办？重新建索引，使用覆盖索引。</p>
<p><strong>使用覆盖索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`tab_person`</span> </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`idx_pcode_pamount`</span> <span class="keyword">USING</span> BTREE (<span class="string">`p_code`</span> <span class="keyword">ASC</span>, <span class="string">`p_amount`</span> <span class="keyword">ASC</span>);</span><br></pre></td></tr></table></figure>

<p>这样再走一遍Explan 执行计划，就发现可以走到索引了。</p>
<h3 id="总结：覆盖索引的优化及限制"><a href="#总结：覆盖索引的优化及限制" class="headerlink" title="总结：覆盖索引的优化及限制"></a>总结：覆盖索引的优化及限制</h3><p> 覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不需要读取数据，有以下优点：</p>
<p> 1、索引项通常比记录要小，所以MySQL访问更少的数据。</p>
<p> 2、索引都按值得大小存储，相对于随机访问记录，需要更少的I/O。</p>
<p> 3、数据引擎能更好的缓存索引，比如MyISAM只缓存索引。</p>
<p> 4、覆盖索引对InnoDB尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引包含查询所需的数据，就不再需要在聚集索引中查找了。</p>
<p> <strong>限制：</strong></p>
<p> 1、覆盖索引也并不适用于任意的索引类型，索引必须存储列的值。</p>
<p> 2、Hash和full-text索引不存储值，因此MySQL只能使用BTree。</p>
<p> 3、不同的存储引擎实现覆盖索引都是不同的，并不是所有的存储引擎都支持覆盖索引。</p>
<p> 4、如果要使用覆盖索引，一定要注意SELECT列表值取出需要的列，不可以SELECT * ，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p>
<p>这篇就写到这里吧，下一篇详细介绍执行计划以及一些其他优化手段。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-APR调优</title>
    <url>/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="Tomcat-APR"><a href="#Tomcat-APR" class="headerlink" title="Tomcat-APR"></a>Tomcat-APR</h2><h3 id="一-APR"><a href="#一-APR" class="headerlink" title="一. APR"></a>一. APR</h3><p>​    APR(Apache Portable Runtime)是Apache Http Server2.0的核心组件，最为Java程序员我们最常用的方式就是将其集成到tomcat中，能够提高tomcat的性能。那么他是如何提高性能的呢？APR能够访问高级IO特性(例如sendfile, epoll, OpenSSL)，OS级别功能(生成随机数，操作系统状态管理), 本地进程操作(共享内存, Unix Sockets)等功能，而我们使用一个叫做 Tomcat Native的中间件，来作为APR和Tomcat的通道，就可以使得Tomcat使用到APR的这些高级特性，例如多路复用技术。</p>
<a id="more"></a>

<h3 id="二-软件下载"><a href="#二-软件下载" class="headerlink" title="二. 软件下载"></a>二. 软件下载</h3><table>
<thead>
<tr>
<th>软件名</th>
<th>下载地址</th>
</tr>
</thead>
<tbody><tr>
<td>apr-1.7.0.tar.gz</td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/apr/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/apr/</a></td>
</tr>
<tr>
<td>apr-util-1.6.1.tar.gz</td>
<td><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/apr/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/apr/</a></td>
</tr>
<tr>
<td>tomcat9</td>
<td><a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-90.cgi</a></td>
</tr>
</tbody></table>
<p><img src="/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/1.png" alt="1"></p>
<h3 id="三-安装APR与Tomcat-Native"><a href="#三-安装APR与Tomcat-Native" class="headerlink" title="三. 安装APR与Tomcat Native"></a>三. 安装APR与Tomcat Native</h3><p><strong>在所有的安装步骤之前需要保证JDK已经安装完成</strong></p>
<h4 id="3-1-APR的安装"><a href="#3-1-APR的安装" class="headerlink" title="3.1 APR的安装"></a>3.1 APR的安装</h4><p>A. 解压<code>apr-1.7.0.tar.gz</code>和<code>apr-util-1.6.1.tar.gz</code>，依次执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf apr-1.7.0.tar.gz </span><br><span class="line">tar -zxf apr-util-1.6.1.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/2.png" alt="2"></p>
<p>B. 进入到解压目录<code>apr-1.7.0</code>下，执行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apr</span><br></pre></td></tr></table></figure>

<p>出现了如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:&#x2F;datas&#x2F;apr-1.7.0# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apr</span><br><span class="line">checking build system type... x86_64-pc-linux-gnu</span><br><span class="line">checking host system type... x86_64-pc-linux-gnu</span><br><span class="line">checking target system type... x86_64-pc-linux-gnu</span><br><span class="line">Configuring APR library</span><br><span class="line">Platform: x86_64-pc-linux-gnu</span><br><span class="line">checking for working mkdir -p... yes</span><br><span class="line">APR Version: 1.7.0</span><br><span class="line">checking for chosen layout... apr</span><br><span class="line">checking for gcc... no</span><br><span class="line">checking for cc... no</span><br><span class="line">checking for cl.exe... no</span><br><span class="line">configure: error: in &#96;&#x2F;datas&#x2F;apr-1.7.0&#39;:</span><br><span class="line">configure: error: no acceptable C compiler found in $PATH</span><br></pre></td></tr></table></figure>

<p>通过安装 <code>gcc</code> 可以解决该问题，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gcc</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/3.png" alt="3"></p>
<p>C. 接着安装<code>apr-1.7.0.tar.gz</code>，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:&#x2F;datas&#x2F;apr-1.7.0# make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">Command &#39;make&#39; not found, but can be installed with:</span><br><span class="line"></span><br><span class="line">apt install make      </span><br><span class="line">apt install make-guile</span><br></pre></td></tr></table></figure>

<p>解决方式，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install automake autoconf libtool make</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/4.png" alt="4"></p>
<p>D. 安装<code>apr-util-1.6.1.tar.gz</code>，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --with-apr&#x3D;&#x2F;usr&#x2F;local&#x2F;apr --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apr-utils --with-java-home&#x3D;&#x2F;datas&#x2F;jdk1.8.0_60 &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>安装过程中会出现如下图所示的错误：</p>
<p><img src="/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/5.png" alt="5"></p>
<p>解决方式，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install libexpat1-dev</span><br></pre></td></tr></table></figure>

<h4 id="3-2-安装tomcat-native"><a href="#3-2-安装tomcat-native" class="headerlink" title="3.2 安装tomcat-native"></a>3.2 安装tomcat-native</h4><p>​    tomcat7以后的版本中都自带了tomcat-native，在tomcat的解压目录下的bin目录下。</p>
<p><img src="/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/6.png" alt="6"></p>
<p>A. 解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxf tomcat-native.tar.gz</span><br></pre></td></tr></table></figure>

<p>B. 进入到tomcat-native的解压目录tomcat-native-1.2.23-src/native下，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --with-apr&#x3D;&#x2F;usr&#x2F;local&#x2F;apr --with-java-home&#x3D;&#x2F;datas&#x2F;jdk1.8.0_60 --with-ssl&#x3D;&#x2F;usr&#x2F;bin&#x2F;openssl --with-ssl&#x3D;yes &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>安装的过程会出现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checking for gcc option to accept ISO C89... none needed</span><br><span class="line">checking for OpenSSL library... not found</span><br><span class="line">configure: error: OpenSSL was not found in any of &#x2F;usr &#x2F;usr&#x2F;local &#x2F;usr&#x2F;local&#x2F;ssl &#x2F;usr&#x2F;pkg &#x2F;usr&#x2F;sfw; use --with-ssl&#x3D;&#x2F;path</span><br></pre></td></tr></table></figure>

<p>解决方式，执行如下命令即可解决问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure>

<p>解决问题参考资料：<a href="https://stackoverflow.com/questions/3016956/how-do-i-install-the-openssl-libraries-on-ubuntu" target="_blank" rel="noopener">https://stackoverflow.com/questions/3016956/how-do-i-install-the-openssl-libraries-on-ubuntu</a></p>
<h3 id="四-Tomcat配置与启动"><a href="#四-Tomcat配置与启动" class="headerlink" title="四. Tomcat配置与启动"></a>四. Tomcat配置与启动</h3><h4 id="4-1-配置环境变量"><a href="#4-1-配置环境变量" class="headerlink" title="4.1 配置环境变量"></a>4.1 配置环境变量</h4><p>​    在/etc/profile文件末尾加上如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;usr&#x2F;local&#x2F;apr&#x2F;lib</span><br></pre></td></tr></table></figure>

<p>执行 source /etc/profile 重新加载环境变量</p>
<h4 id="4-2-tomcat配置"><a href="#4-2-tomcat配置" class="headerlink" title="4.2 tomcat配置"></a>4.2 tomcat配置</h4><p>A. 在tomcat解压目录下的bin目录下，创建名为<code>setenv.sh</code>的文件，在文件中写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:$CATALINA_HOME&#x2F;lib</span><br><span class="line">export LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>参考文档：<a href="http://tomcat.apache.org/native-doc/" target="_blank" rel="noopener">http://tomcat.apache.org/native-doc/</a></p>
<p>B. 修改tomcat的配置文件server.xml(apache-tomcat-9.0.22/conf目录下)，修改之前的内容为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 中间内容省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改之后的内容为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"off"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 中间内容省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>C. 启动Tomcat，在日志中如果出现以下内容，表示tomcat的APR模式配置成功</p>
<p><img src="/2020/03/01/Tomcat-APR%E8%B0%83%E4%BC%98/7.png" alt="7"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>商城秒杀(一)</title>
    <url>/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><strong>秒杀系统的概述</strong></p>
<p>  在当前的互联网环境下，高并发随时都在进行，比如春运抢票。高并发对web程序其实是一个极大的考验，秒杀系统是一个非常普遍并且全面的一种高并发的应对系统。高并发本身并没有完整而权威的解决方案，只有通过前人的积累和经验。</p>
<a id="more"></a>

<h2 id="秒杀和传统购买的区别："><a href="#秒杀和传统购买的区别：" class="headerlink" title="秒杀和传统购买的区别："></a><strong>秒杀和传统购买的区别：</strong></h2><p>  1、瞬间请求巨大 </p>
<p>  2、通常秒杀有数量的限制 </p>
<p>  3、秒杀通常不会添加购物车  </p>
<p>  4、秒杀通常有时间限制  </p>
<p>  5、秒杀通常需要引入排队机制 </p>
<h2 id="秒杀系统的难度："><a href="#秒杀系统的难度：" class="headerlink" title="秒杀系统的难度："></a><strong>秒杀系统的难度：</strong></h2><p>   1、高并发的处理（贯穿整个项目）  </p>
<p>   2、秒杀倒计时的实现（客户端统一倒计时）  </p>
<p>   3、秒杀商品的库存判定（防止高并发下的超卖情况）   </p>
<p>   4、防止提前下单  </p>
<p>   5、抢购完成后的排队问题</p>
<h2 id="秒杀系统的架构图"><a href="#秒杀系统的架构图" class="headerlink" title="秒杀系统的架构图"></a><strong>秒杀系统的架构图</strong></h2><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/01.png">

<h2 id="秒杀系统的数据设计"><a href="#秒杀系统的数据设计" class="headerlink" title="秒杀系统的数据设计"></a><strong>秒杀系统的数据设计</strong></h2><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/02.png">

<h2 id="秒杀商品详细的展示与设计"><a href="#秒杀商品详细的展示与设计" class="headerlink" title="秒杀商品详细的展示与设计"></a><strong>秒杀商品详细的展示与设计</strong></h2><p>秒杀详情页的并发量相对较大，并且在秒杀快开始时，可能会有大量的用户刷新详情页，这是对服务器的压力相对较大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方案：秒杀详情页静态化处理</span><br><span class="line"></span><br><span class="line">什么是页面静态化？ - 服务器提前将需要展示的页面生成静态页，</span><br><span class="line">客户端直接访问静态页即可，无需再查询数据库，动态渲染页面的过程。</span><br><span class="line"></span><br><span class="line">页面静态化两大前提：</span><br><span class="line">    1、访问量很大</span><br><span class="line">    2、页面变化频率低</span><br><span class="line"></span><br><span class="line">注意：页面静态化并不意味着页面不能有动态的部分，动态的部分完全可以用ajax实现</span><br><span class="line"></span><br><span class="line">如何生成静态页？ </span><br><span class="line">这个好解决，用了最多的就是   Freemarker</span><br><span class="line"></span><br><span class="line">    1、添加依赖</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-freemarker&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    2、添加freemarker模板</span><br><span class="line">一般都放在你的Resources目录下</span><br><span class="line"></span><br><span class="line">    3、注解Freemarker配置对象</span><br><span class="line">@RabbitListener(queues &#x3D; &quot;kill_queue&quot;)</span><br><span class="line">public void msgHandler(Goods goods)&#123;</span><br><span class="line">    &#x2F;&#x2F;生成静态页面</span><br><span class="line">    System.out.println(&quot;接收到消息生成静态页:&quot; + goods);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获得classpath路径</span><br><span class="line">    String path &#x3D; MyRabbitListener.class.getResource(&quot;&#x2F;&quot;).getPath() + &quot;static&#x2F;html&quot;;</span><br><span class="line">    System.out.println(&quot;classpath:&quot; + path);</span><br><span class="line">    File file &#x3D; new File(path);</span><br><span class="line">    if(!file.exists())&#123;</span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    file &#x3D; new File(file, goods.getId() + &quot;.html&quot;);</span><br><span class="line">    try(</span><br><span class="line">            &#x2F;&#x2F;准备一个静态页的输出路径</span><br><span class="line">            Writer out &#x3D; new FileWriter(file)</span><br><span class="line">    ) &#123;</span><br><span class="line">        &#x2F;&#x2F;获得对应的模板</span><br><span class="line">        Template template &#x3D; configuration.getTemplate(&quot;kill.ftlh&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;准备数据</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;goods&quot;, goods);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;生成静态页</span><br><span class="line">        template.process(map, out);</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有一个特别需要注意的点！</strong></p>
<h2 id="秒杀详情页的倒计时"><a href="#秒杀详情页的倒计时" class="headerlink" title="秒杀详情页的倒计时"></a>秒杀详情页的倒计时</h2><p>注意：<br>1、倒计时的当前时间必须从服务器获取<br>2、服务器集群之间通过时间服务进行统一<br>3、时间倒计时的功能应该在客户端实现</p>
<p>这里我想到一种思路，直接上代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;商品开始抢购的时间</span><br><span class="line">var startTime &#x3D; new Date(&#39;$&#123;goods.goodsKill.startTime?datetime&#125;&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当前时间</span><br><span class="line">var now;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;计数器</span><br><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 倒计时功能</span><br><span class="line">*&#x2F;</span><br><span class="line">function djs()&#123;</span><br><span class="line">    &#x2F;&#x2F;计算时间差</span><br><span class="line">    var times &#x3D; startTime.getTime() - now.getTime();</span><br><span class="line"></span><br><span class="line">    if(times &lt;&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;秒杀已经开始了</span><br><span class="line">        alert(&quot;秒杀开始了！&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;秒杀还未开始，计算倒计时</span><br><span class="line">    var h &#x3D; parseInt(times&#x2F;1000&#x2F;60&#x2F;60);&#x2F;&#x2F;还剩多少小时</span><br><span class="line">    var m &#x3D; parseInt(times&#x2F;1000&#x2F;60%60);&#x2F;&#x2F;还剩多少分钟</span><br><span class="line">    var s &#x3D; parseInt(times&#x2F;1000%60);&#x2F;&#x2F;还剩多少秒</span><br><span class="line">    var ms &#x3D; parseInt(times%1000);&#x2F;&#x2F;还剩多少毫秒 867</span><br><span class="line"></span><br><span class="line">    var djsTime &#x3D; formatTime(h) + &quot;:&quot; + formatTime(m) + &quot;:&quot; + formatTime(s);</span><br><span class="line">    $(&quot;#djs&quot;).html(djsTime);</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        if(count &gt;&#x3D; 60)&#123;</span><br><span class="line">            console.log(&quot;主动获取服务器的时间！&quot;);</span><br><span class="line">            &#x2F;&#x2F;重新获取服务器的时间</span><br><span class="line">            getServerNow();</span><br><span class="line">            count &#x3D; 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            now.setSeconds(now.getSeconds() + 1);</span><br><span class="line">            now.setMilliseconds(now.getMilliseconds() + ms);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        djs();</span><br><span class="line">    &#125;, 1000 + ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 获得服务器的当前时间</span><br><span class="line">*&#x2F;</span><br><span class="line">function getServerNow()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: &quot;GET&quot;,</span><br><span class="line">        url: &quot;&#x2F;kill&#x2F;queryNow&quot;,</span><br><span class="line">        async: false,&#x2F;&#x2F;设置为同步的ajax</span><br><span class="line">        success: function(data)&#123;</span><br><span class="line">            if(data.code &#x3D;&#x3D; &quot;200&quot;)&#123;</span><br><span class="line">                now &#x3D; new Date(data.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 格式化当前时间</span><br><span class="line">*&#x2F;</span><br><span class="line">function formatTime(n)&#123;</span><br><span class="line">    if(n &lt; 10)&#123;</span><br><span class="line">        return &quot;0&quot; + n;</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 页面加载后触发</span><br><span class="line">*&#x2F;</span><br><span class="line">$(function()&#123;</span><br><span class="line">    &#x2F;&#x2F;获取当前时间</span><br><span class="line">    getServerNow();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;开始倒计时</span><br><span class="line">    djs();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">问题：谷歌浏览器有一个节能机制，一旦页签没有焦点（浏览器最小化，切换到其他页签等）,setTimeout方法触发会变慢，默认延迟1S</span><br><span class="line">解决办法：</span><br><span class="line">&#x2F;**</span><br><span class="line">* 监听到浏览器的隐藏和显示时间</span><br><span class="line">*&#x2F;</span><br><span class="line">document.addEventListener(&#39;visibilitychange&#39;,function()&#123; &#x2F;&#x2F;浏览器切换事件</span><br><span class="line">    if(document.visibilityState&#x3D;&#x3D;&#39;hidden&#39;) &#123; &#x2F;&#x2F;状态判断</span><br><span class="line">        &#x2F;&#x2F;console.log(&quot;隐藏了！！&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;停止定时器</span><br><span class="line">        clearTimeout(mytime);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;console.log(&quot;可见了！！&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取当前时间</span><br><span class="line">        getServerNow();</span><br><span class="line">        &#x2F;&#x2F;开始倒计时</span><br><span class="line">        djs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="秒杀抢购的实现与设计"><a href="#秒杀抢购的实现与设计" class="headerlink" title="秒杀抢购的实现与设计"></a>秒杀抢购的实现与设计</h2><h3 id="如何防止秒杀提前下单"><a href="#如何防止秒杀提前下单" class="headerlink" title="如何防止秒杀提前下单"></a><strong>如何防止秒杀提前下单</strong></h3><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/03.png">

<p><strong>思路：</strong></p>
<h4 id="1、发布秒杀商品信息时，同步到redis中："><a href="#1、发布秒杀商品信息时，同步到redis中：" class="headerlink" title="1、发布秒杀商品信息时，同步到redis中："></a>1、发布秒杀商品信息时，同步到redis中：</h4><h4 id="2、秒杀服务设置整点定时器，整点触发（可以根据业务动态调整）（Quartz、Spring-task）："><a href="#2、秒杀服务设置整点定时器，整点触发（可以根据业务动态调整）（Quartz、Spring-task）：" class="headerlink" title="2、秒杀服务设置整点定时器，整点触发（可以根据业务动态调整）（Quartz、Spring-task）："></a>2、秒杀服务设置整点定时器，整点触发（可以根据业务动态调整）（Quartz、Spring-task）：</h4><h4 id="3、下单时验证商品是否开抢："><a href="#3、下单时验证商品是否开抢：" class="headerlink" title="3、下单时验证商品是否开抢："></a>3、下单时验证商品是否开抢：</h4><p>​         <strong>秒杀下单是否需要引入验证码？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">需要验证码的原因：    </span><br><span class="line"><span class="number">1</span>、防止恶意提交数据（比如秒杀器）    </span><br><span class="line"><span class="number">2</span>、延长用户的请求时间引入验证码：    </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、添加依赖    &lt;dependency&gt;    </span><br><span class="line">                 &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;    </span><br><span class="line">                 &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;   </span><br><span class="line">                 &lt;version&gt;2.3.2&lt;/version&gt;  </span><br><span class="line">              &lt;/dependency&gt;        </span><br><span class="line"><span class="number">2</span>、配置验证码   </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultKaptcha <span class="title">getKaptcha</span><span class="params">()</span></span>&#123;    </span><br><span class="line">DefaultKaptcha defaultKaptcha = <span class="keyword">new</span> DefaultKaptcha();    </span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();    <span class="comment">// 图片边框   </span></span><br><span class="line">properties.setProperty(<span class="string">"kaptcha.border"</span>, <span class="string">"yes"</span>);    <span class="comment">// 边框颜色    properties.setProperty("kaptcha.border.color", "105,179,90");    // 字体颜色    properties.setProperty("kaptcha.textproducer.font.color", "red");    // 图片宽    properties.setProperty("kaptcha.image.width", "110");    // 图片高    properties.setProperty("kaptcha.image.height", "40");    // 字体大小    properties.setProperty("kaptcha.textproducer.font.size", "30");    // session key    properties.setProperty("kaptcha.session.key", "code");    // 验证码长度    properties.setProperty("kaptcha.textproducer.char.length", "4");    // 字体    properties.setProperty("kaptcha.textproducer.font.names", "宋体,楷体,微软雅黑");    defaultKaptcha.setConfig(new Config(properties));    </span></span><br><span class="line"><span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="number">3</span>、在代码中注入使用</span><br><span class="line"><span class="comment">/*** 获得验证码*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/code"</span>)<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCode</span><span class="params">(HttpServletResponse response)</span></span>&#123;    <span class="comment">//验证码的文本   </span></span><br><span class="line">String text = defaultKaptcha.createText();    <span class="comment">//根据验证码的文本生成图片    </span></span><br><span class="line">BufferedImage image = defaultKaptcha.createImage(text);    <span class="comment">//将二维码图片设置到浏览器端    </span></span><br><span class="line"><span class="keyword">try</span> &#123;        </span><br><span class="line">ImageIO.write(image, <span class="string">"jpg"</span>, response.getOutputStream());    &#125; <span class="keyword">catch</span> (IOException e) &#123;        e.printStackTrace();   </span><br><span class="line">                                                                                    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、验证码的判定和防止提前下单的判定，可以放到gateway端实现"><a href="#4、验证码的判定和防止提前下单的判定，可以放到gateway端实现" class="headerlink" title="4、验证码的判定和防止提前下单的判定，可以放到gateway端实现"></a>4、验证码的判定和防止提前下单的判定，可以放到gateway端实现</h4><h4 id="5、防止重复下单：基于路由网关的拦截器，可以实现防止重复下单"><a href="#5、防止重复下单：基于路由网关的拦截器，可以实现防止重复下单" class="headerlink" title="5、防止重复下单：基于路由网关的拦截器，可以实现防止重复下单"></a>5、防止重复下单：基于路由网关的拦截器，可以实现防止重复下单</h4><h2 id="下单的业务流程"><a href="#下单的业务流程" class="headerlink" title="下单的业务流程"></a><strong>下单的业务流程</strong></h2><p>这里一定要考虑到的一个高并发时候存在的各种问题（我能想到多少我就写了多少，后期能想到再更新）</p>
<h4 id="1、高并发下的库存安全问题"><a href="#1、高并发下的库存安全问题" class="headerlink" title="1、高并发下的库存安全问题"></a>1、高并发下的库存安全问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#秒杀库存一致性的测试</span><br><span class="line"></span><br><span class="line">#测试的条件：数据库给了一张表，库存设定1W，再开启了1W5的Thread去抢</span><br><span class="line"></span><br><span class="line">#方案一：直接操作数据库，没有任何线程同步，发生了超卖，耗时7S</span><br><span class="line"></span><br><span class="line">#方案二：使用同步关键字，没有发生超卖，耗时19S</span><br><span class="line"></span><br><span class="line">#方案三：数据库的锁</span><br><span class="line">    #乐观锁 - 最后提交修改时，做一个版本判定  </span><br><span class="line">    #悲观锁 - 在操作数据前，直接加锁，修改完后，再解锁</span><br><span class="line">    #表锁 - 锁表（MySQL5.5之前，只有表锁）</span><br><span class="line">    #行锁 - 锁行（MySQL5.5之后，引入了行锁）    </span><br><span class="line">    #   - 共享锁(悲观锁)：一个事务对某一行数据添加共享锁之后，其他的事务只能再添加共享锁，不能添加排他锁</span><br><span class="line">    #   - *排他锁(悲观锁)：一个事务对某一行数据添加排他锁之后，其他事务不能再添加排他锁和共享锁</span><br><span class="line">    #mysql中，所有的insert、update、delete语句，自带排他锁。select默认不带任何锁。</span><br><span class="line">    #给select语句添加排他锁: select * from table where id &#x3D; 1 for update</span><br><span class="line">#数据库的悲观锁的方案，没有发生超卖，耗时10S</span><br><span class="line">#数据库的乐观锁的方案，没有发生超卖，耗时7S（商用）</span><br><span class="line"></span><br><span class="line">#方案四：redis+lua脚本的方式，没有发生超卖，耗时2S（）</span><br><span class="line">--获得参数</span><br><span class="line">local gid &#x3D; KEYS[1]</span><br><span class="line">local gnumber &#x3D; tonumber(ARGV[1])</span><br><span class="line">--订单对象</span><br><span class="line">local order &#x3D; ARGV[2]</span><br><span class="line"></span><br><span class="line">--获得库存</span><br><span class="line">local gsave &#x3D; tonumber(redis.call(&#39;get&#39;, &#39;gsave_&#39;..gid))</span><br><span class="line">--判断库存</span><br><span class="line">if gsave &lt; gnumber then</span><br><span class="line">    --库存不足</span><br><span class="line">    return -1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--修改库存</span><br><span class="line">local newSave &#x3D; tonumber(redis.call(&#39;decrby&#39;, &#39;gsave_&#39;..gid, gnumber))</span><br><span class="line">--保存订单信息</span><br><span class="line">redis.call(&#39;lpush&#39;, &#39;orders_&#39;..gid, order)</span><br><span class="line"></span><br><span class="line">if newSave &gt; 0 then</span><br><span class="line">    --还没抢完</span><br><span class="line">    return 1</span><br><span class="line">else</span><br><span class="line">    --抢完了</span><br><span class="line">    return 2    </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="2、Redis如何操作Lua脚本？"><a href="#2、Redis如何操作Lua脚本？" class="headerlink" title="2、Redis如何操作Lua脚本？"></a>2、Redis如何操作Lua脚本？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式： eval script numkeys key.... arg.....</span><br><span class="line">eval - 关键字表示执行lua脚本</span><br><span class="line">script - lua脚本的内容</span><br><span class="line">numkeys - 表示lua脚本中key变量的数量</span><br><span class="line">key... - key变量的数组</span><br><span class="line">arg... - 普通变量的数组</span><br><span class="line"></span><br><span class="line">lua脚本如何执行redis命令：</span><br><span class="line">redis.call(&#39;命令&#39;) - 比如： set name xiaoming -&gt; redis.call(&#39;set&#39;, &#39;name&#39;, &#39;小明&#39;)</span><br><span class="line"></span><br><span class="line">案例：</span><br><span class="line">eval &quot;return &#39;Hello World!&#39;&quot; 0  -  返回HelloWorld字符串</span><br><span class="line">eval &quot;redis.call(&#39;set&#39;, &#39;name&#39;, &#39;xiaoming&#39;)&quot; 0 - 执行redis命令</span><br><span class="line">eval &quot;return redis.call(&#39;get&#39;, &#39;name&#39;)&quot; 0</span><br><span class="line">eval &quot;redis.call(&#39;set&#39;, KEYS[1], ARGV[1])&quot; 1 name xiaohei</span><br><span class="line">eval &quot;local key &#x3D; KEYS[1] local money &#x3D; tonumber(redis.call(&#39;get&#39;, key)) if money &gt;&#x3D; 10000 then return &#39;yq&#39; else return &#39;qb&#39; end&quot; 1 money</span><br><span class="line">上面语句等价于下面这个：</span><br><span class="line">&#123;</span><br><span class="line">    --获得key变量</span><br><span class="line">    local key &#x3D; KEYS[1]</span><br><span class="line">    </span><br><span class="line">    --读取对应的金额：tonumber内置函数转为数字</span><br><span class="line">    local money &#x3D; tonumber(redis.call(&#39;get&#39;, key))</span><br><span class="line"></span><br><span class="line">    --判断</span><br><span class="line">    if money &gt;&#x3D; 10000 then</span><br><span class="line">        --大于10000</span><br><span class="line">        return &quot;有钱&quot;</span><br><span class="line">    else</span><br><span class="line">        --小于10000</span><br><span class="line">        return &quot;穷B&quot;</span><br><span class="line">    end  </span><br><span class="line">    --一个key输出的是money</span><br><span class="line">    1 money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：lua脚本中千万不能执行耗时操作，redis默认有一个耗时的阈值，</span><br><span class="line">     一旦lua脚本执行超过5S就会停止执行。</span><br><span class="line"></span><br><span class="line">lua脚本的缓存：</span><br><span class="line">script load &quot;script&quot;  - 缓存脚本，返回脚本对应的sha签名</span><br><span class="line">evalsha &quot;sha1&quot; numkeys key... arg... - 根据sha签名执行缓存后的lua脚本</span><br><span class="line">如下图：</span><br></pre></td></tr></table></figure>

<img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/04.png">

<h4 id="3、SpringBoot如何执行Lua脚本"><a href="#3、SpringBoot如何执行Lua脚本" class="headerlink" title="3、SpringBoot如何执行Lua脚本?"></a>3、SpringBoot如何执行Lua脚本?</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">@Test</span><br><span class="line">void redisScript()&#123;</span><br><span class="line">    String lua &#x3D; &quot;local key &#x3D; KEYS[1] local money &#x3D; tonumber(redis.call(&#39;get&#39;, key)) if money &gt;&#x3D; 10000 then return &#39;yq&#39; else return &#39;qb&#39; end&quot;</span><br><span class="line">    </span><br><span class="line">    String result &#x3D; (String) stringRedisTemplate.execute(  &#x2F;&#x2F;非序列化模板对象，值没有被序列化可以用这个对象调方法</span><br><span class="line">            new DefaultRedisScript(lua, String.class),</span><br><span class="line">            Collections.singletonList(&quot;money&quot;));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数1：redis默认脚本对象，其中对象的参数一为脚本语句，参数二为返回值类型</span><br><span class="line">参数2：list集合</span><br><span class="line">Collections.singletonList(&quot;money&quot;)：只有一个值得时候，可以这样创建集合</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">@Test</span><br><span class="line">void redisScript2()&#123;</span><br><span class="line">    &#x2F;&#x2F;获得redis的原始连接</span><br><span class="line">    RedisConnection connection &#x3D; redisTemplate.getConnectionFactory().getConnection();  &#x2F;&#x2F;序列化模板对象</span><br><span class="line">    byte[] eval &#x3D; connection.eval(lua.getBytes(), ReturnType.VALUE, 1, &quot;money&quot;.getBytes());</span><br><span class="line">    System.out.println(&quot;eval-&gt;&quot; + new String(eval));</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数1：脚本字节数组</span><br><span class="line">参数2：返回值类型</span><br><span class="line">参数3：key的数量</span><br><span class="line">参数4：key的名称转化为字节数组</span><br></pre></td></tr></table></figure>

<h4 id="4、高并发下如何保证数据一致性？（这个是我面试被问到最高频的问题）"><a href="#4、高并发下如何保证数据一致性？（这个是我面试被问到最高频的问题）" class="headerlink" title="4、高并发下如何保证数据一致性？（这个是我面试被问到最高频的问题）"></a>4、高并发下如何保证数据一致性？（这个是我面试被问到最高频的问题）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis+Lua可以起到分布式锁的作用，再加上消息中间件RabbitMq做消息队列持久化，</span><br><span class="line">绑定死信队列，保证最终一致性，死性队列接受异常消费的消息，</span><br><span class="line">可以做回滚，或者记录日志，再有RabbitMQ有消息确认机制，</span><br><span class="line">通过这几种方式以保证数据的最终一致性。</span><br></pre></td></tr></table></figure>

<h5 id="1、什么是死信队列？"><a href="#1、什么是死信队列？" class="headerlink" title="1、什么是死信队列？"></a>1、什么是死信队列？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当一个普通队列中，产生一个死信消息时，默认死信消息会被丢弃。</span><br><span class="line">但是如果这个队列判定了死信交换机，则这个死信消息会发送给死信交换机，</span><br><span class="line">和死信交换机绑定的队列，称之为死信队列</span><br></pre></td></tr></table></figure>

<h5 id="2、什么是死信消息？"><a href="#2、什么是死信消息？" class="headerlink" title="2、什么是死信消息？"></a>2、什么是死信消息？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如下情况会产生死信消息：</span><br><span class="line">1、消息过期</span><br><span class="line">2、队列已满，继续添加消息</span><br><span class="line">3、消费者拒绝消费消息，并且requeue设置为false</span><br></pre></td></tr></table></figure>

<img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/05.png">

<h5 id="3、如何设置死信队列？"><a href="#3、如何设置死信队列？" class="headerlink" title="3、如何设置死信队列？"></a>3、如何设置死信队列？</h5><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/06.png">

<h2 id="分布式下多数据库的事务一致性问题（分布式事务）"><a href="#分布式下多数据库的事务一致性问题（分布式事务）" class="headerlink" title="分布式下多数据库的事务一致性问题（分布式事务）"></a>分布式下多数据库的事务一致性问题（分布式事务）</h2><h3 id="1、2PC-两段提交协议"><a href="#1、2PC-两段提交协议" class="headerlink" title="1、2PC - 两段提交协议"></a>1、2PC - 两段提交协议</h3><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/07.png">

<h3 id="2、TCC-柔性事务"><a href="#2、TCC-柔性事务" class="headerlink" title="2、TCC - 柔性事务"></a>2、TCC - 柔性事务</h3><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/08.png">

<h3 id="3、基于MQ的最终一致性解决方案"><a href="#3、基于MQ的最终一致性解决方案" class="headerlink" title="3、基于MQ的最终一致性解决方案"></a>3、基于MQ的最终一致性解决方案</h3><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/09.png">

<h2 id="1、秒杀的流程结构图"><a href="#1、秒杀的流程结构图" class="headerlink" title="1、秒杀的流程结构图"></a>1、秒杀的流程结构图</h2><img src="/2020/03/23/%E5%95%86%E5%9F%8E%E7%A7%92%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89/10.png">

<h2 id="2、-秒杀排队的实现"><a href="#2、-秒杀排队的实现" class="headerlink" title="2、 秒杀排队的实现"></a>2、 秒杀排队的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过集群RabbitMQ，采用Redis缓存+MQ轮询机制+Hystrix+getwa路由网关实现</span><br></pre></td></tr></table></figure>

<h2 id="3、下单防止重复提交的实现"><a href="#3、下单防止重复提交的实现" class="headerlink" title="3、下单防止重复提交的实现"></a>3、下单防止重复提交的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么会发生重复提交的问题？</span><br><span class="line">    - 前端的bug，点击后发生卡顿，用户以为没有点击，导致返回点击提交按钮</span><br><span class="line">    - 触屏手机可能会将用户的一次点击识别成多次点击</span><br><span class="line">    - 后端通过转发的方式跳转页面 - 将结果页以重定向的方式返回</span><br><span class="line">    </span><br><span class="line">解决重复提交的问题：</span><br><span class="line">[1]下单后Redis记录用户信息添加到缓存，再次提交抢购请求时拒绝用户请求（麻烦）</span><br><span class="line">[2]用户进入到抢购页面，这时浏览器发送一个Ajax请求给服务器。</span><br><span class="line">   服务器接收到请求生成一个UUID返回给浏览器，浏览器提交请求的时候拿到</span><br><span class="line">   服务器生成的UUID,当用户执行完秒杀下单操作后，服务器这边把UUID从缓存</span><br><span class="line">   中删除掉，当用户再次发起请求的时候UUID已经从缓存中删除了，这样起到防止重复提交。</span><br></pre></td></tr></table></figure>

<h2 id="4、路由网关限流"><a href="#4、路由网关限流" class="headerlink" title="4、路由网关限流"></a>4、路由网关限流</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">限流算法：令牌桶算法</span><br><span class="line">gateway实现限流</span><br><span class="line"></span><br><span class="line">1、gateway路由网关配置redis依赖</span><br><span class="line"></span><br><span class="line">2、给指定的路由，配置限流过滤器</span><br><span class="line">#秒杀服务的路由规则</span><br><span class="line">- id: kill2</span><br><span class="line">  uri: lb:&#x2F;&#x2F;MICSERVICE-KILL</span><br><span class="line">  predicates:</span><br><span class="line">    - Path&#x3D;&#x2F;kill&#x2F;qiangGou</span><br><span class="line">  filters:</span><br><span class="line">    - myCode</span><br><span class="line">    - myKill</span><br><span class="line">    - name: RequestRateLimiter</span><br><span class="line">      args:</span><br><span class="line">        #限流规则</span><br><span class="line">        key-resolver: &#39;#&#123;@remoteAddrKeyResolver&#125;&#39;</span><br><span class="line">        #放令牌的速率 1S&#x2F;5个</span><br><span class="line">        redis-rate-limiter.replenishRate: 5</span><br><span class="line">        #令牌桶的容量 总共10个</span><br><span class="line">        redis-rate-limiter.burstCapacity: 10</span><br><span class="line"></span><br><span class="line">3、配置限流规则</span><br><span class="line">@Bean(name &#x3D; &quot;remoteAddrKeyResolver&quot;)</span><br><span class="line">    public KeyResolver getKeyResolver()&#123;</span><br><span class="line">        return new KeyResolver() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Mono&lt;String&gt; resolve(ServerWebExchange exchange) &#123;</span><br><span class="line">&#x2F;&#x2F;                &#x2F;&#x2F;ip限流</span><br><span class="line">&#x2F;&#x2F;                return Mono.just(exchange.getRequest().getRemoteAddress().getHostName());</span><br><span class="line">                &#x2F;&#x2F;url限流</span><br><span class="line">                return Mono.just(exchange.getRequest().getURI().getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="高并发的方案设计构思"><a href="#高并发的方案设计构思" class="headerlink" title="高并发的方案设计构思"></a>高并发的方案设计构思</h2><p>  <strong>前端：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端做好用户的体验反馈效果，让用户感知操作的及时提交，防止用户反复点击按钮提交请求</span><br></pre></td></tr></table></figure>

<p>  <strong>后端：</strong>     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、路由网关层（gateway、nginx）可以进行请求的限制（无效请求的处理、请求的限流、请求的黑白名单....）     </span><br><span class="line">2、服务器进行 集群搭建（高可用处理），起到分流请求的作用     </span><br><span class="line">3、服务和服务之间可以通过MQ进行请求削峰，减缓下游服务器的压力，拉长用户的响应时间    </span><br><span class="line">4、使用缓存服务器（redis集群），进行热门数据的缓存     </span><br><span class="line">5、服务和服务之间通过Hystrix进行服务的隔离（自动降级），也可以通过技术手段进行手动降级    </span><br><span class="line">6、通过MQ的最终一致性保证数据库之间事务一致（分布式事务）     </span><br><span class="line">7、数据库做好优化（分库分表、读写分离）</span><br></pre></td></tr></table></figure>

<p>啊！写完了😭，加油！奥利给！</p>
]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构分析以及HashMap源码分析</title>
    <url>/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="一-数据结构"><a href="#一-数据结构" class="headerlink" title="一. 数据结构"></a>一. 数据结构</h3><p>  线性数据结构（数组、链表、栈、队列）和非线性数据结构（树、图、集合）。</p>
<h4 id="1-1-数组"><a href="#1-1-数组" class="headerlink" title="1.1 数组"></a>1.1 数组</h4><pre><code>数组在内存中必须是连续的内存空间。 </code></pre><h4 id="1-2-链表"><a href="#1-2-链表" class="headerlink" title="1.2 链表"></a>1.2 链表</h4><p>​    有了数组为什么会有链表？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 内存分配； </span><br><span class="line">2.由于其非连续内存的特性导致链表非常适用于频繁插入、删除的场景，而不见长于读取场景，这跟数组的特性恰好形成互补，链表的特性与数组互补，各有所长，而且链表由于指针的存在可以形成环形链表，在特定场景也非常有用，因此链表的存在是很有必要的。</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="二-ArrayList与LinkedList"><a href="#二-ArrayList与LinkedList" class="headerlink" title="二. ArrayList与LinkedList"></a>二. ArrayList与LinkedList</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList和LinkedList区别（Google答案后才发现的...这是一道蚂蚁金服的面试题）</span><br><span class="line"> 1. 是否保证线程安全： ArrayList 和 LinkedList   都是不同步的，也就是不保证线程安全；</span><br><span class="line"> 2. 底层数据结构： Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向链表数据结构</span><br><span class="line"> 3. 插入和删除是否受元素位置的影响：</span><br><span class="line"> ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</span><br><span class="line"> 比如：执行add(E e)方法的时候，ArrayList 会默认在将指定的元素追加到此列表的末尾，</span><br><span class="line"> 这种情况时间复杂度就是 O(1)。</span><br><span class="line"> 但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。</span><br><span class="line"> 因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</span><br><span class="line"> </span><br><span class="line"> ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O(1)而数组为近似O（n）。</span><br><span class="line"></span><br><span class="line">4. 是否支持快速随机访问：LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</span><br><span class="line"> 5. 内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</span><br><span class="line"></span><br><span class="line">什么时候用？</span><br><span class="line">当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；</span><br><span class="line">当操作是在一列数据的前面或中 间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。</span><br></pre></td></tr></table></figure>



<h4 id="2-1-ArrayList源码"><a href="#2-1-ArrayList源码" class="headerlink" title="2.1 ArrayList源码"></a>2.1 ArrayList源码</h4><p>A. 初始化的容量</p>
<p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1583734320294.png" alt="1583734320294"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList如果没有指定容量，默认容量是10.</span><br></pre></td></tr></table></figure>

<p>B. 数组的扩容(准确上来讲就是生成新的数组)</p>
<p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1583734243613.png" alt="1583734243613"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果容量不够了，扩容，按照1.5倍来扩容。</span><br></pre></td></tr></table></figure>

<p>C. 面试常问的点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面试：我们都知道，数组的长度一旦确定了，长度是不能动态修改的，那么问题来了，ArrayList首次添加数据的时候，长度初始化为10，那么当添加到第11个数据的时候，为什么能添加进去？</span><br><span class="line">答: 如果ArrayList内存储数据的数组的长度不够了，会生成新的数组，新数组的长度是老的数组的1.5倍，然后将老</span><br><span class="line">的数组的数据拷贝到新的数组中。</span><br></pre></td></tr></table></figure>

<p>D. ArrayList可优化的点</p>
<p>ArrayList优化的点：给这个ArrayList设置初始化的容量，目的是在数据添加的时候，不会扩容，因为扩容为影响性能。但是如果用不了那么多，会浪费空间。</p>
<h4 id="2-2-LinkedList"><a href="#2-2-LinkedList" class="headerlink" title="2.2 LinkedList"></a>2.2 LinkedList</h4><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1583734602704.png" alt="1583734602704"></p>
<h3 id="三-二叉树"><a href="#三-二叉树" class="headerlink" title="三. 二叉树"></a>三. 二叉树</h3><p>​    二叉树的遍历：Pre-order(root-left-right) In-order(left-root-right) Post-order(left-right-root) .</p>
<p>前序、中序、后序没有工程价值，在实际应用场景中用的最多的深度、广度的遍历。</p>
<h3 id="四-HashMap"><a href="#四-HashMap" class="headerlink" title="四. HashMap"></a>四. HashMap</h3><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1583806000269.png" alt="1583806000269"></p>
<h4 id="4-1-HashMap与HashTable有何区别？"><a href="#4-1-HashMap与HashTable有何区别？" class="headerlink" title="4.1 HashMap与HashTable有何区别？"></a>4.1 HashMap与HashTable有何区别？</h4><p><img src="/2020/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1583806130513.png" alt="1583806130513"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从上面的源码注释CV过去翻译得知......基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（线程不安全和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</span><br><span class="line">..........我吐了</span><br><span class="line">HashMap是线程不安全的，为什么？ 因为允许它的Key为NUll,在高并发的情况下会发生以下两种情况：</span><br><span class="line">[1]会形成环形数据链表</span><br><span class="line">[2]发生数据覆盖问题</span><br><span class="line">        当一个线程进来的时候，开始判断索引值，</span><br><span class="line">        如果索引值为空，当它开始new对象时，代码还没来得及执行，</span><br><span class="line">        第二个线程进来，会直接判断为null，会把之前的数据给覆盖掉，</span><br><span class="line">        发生数据覆盖问题</span><br><span class="line">HashTable是线程安全的，它不允许key为null</span><br></pre></td></tr></table></figure>

<h4 id="4-2-线程不安全的？"><a href="#4-2-线程不安全的？" class="headerlink" title="4.2 线程不安全的？"></a>4.2 线程不安全的？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果两个线程并发，会同时判断到同一个桶位没有数据，会导致一个覆盖另外一个</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  /</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4-3-源码分析"><a href="#4-3-源码分析" class="headerlink" title="4.3 源码分析"></a>4.3 源码分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的初始化容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的加载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链上扩容的阈值，其实只是作为一个判断的标准，并不是8，而是如果当链上的数据大于等于8的时候，如果数组的长度小于64，会进行扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由树变为链的最小长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转树的最小数组容量，只有当数组的长度大于64的时候，链表才会转树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p><strong>resize()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">源码：</span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    	<span class="comment">//如果是第一次put值，会在putVal() 中调用resize(), table是null；</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 第一次 oldCap 是一个 0；从第二次开始就是之前的容量的值</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// threshold是阈值， 第一次oldThr也是0; 之后从第二次开始就是之前的值，</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">//定义新的容量和新的阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果老的容量超过了最大的允许的存储范围，直接调整阈值</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// oldCap &lt;&lt; 1在老的容量上扩大一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//将阈值扩大一倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;              </span><br><span class="line">            <span class="comment">// 第一put值的时候，将16赋值给新的容量</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            <span class="comment">// 第一put值的时候, newThr是 0.75 * 16 = 12</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将HashMap的阈值(成员变量)，赋值为12</span></span><br><span class="line">        threshold = newThr;  </span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    		<span class="comment">// 第一put值的时候，定义一个长度为16的Node数组。之后会按照32、64、128来进行扩容</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        <span class="comment">// 将新生产的数据赋值给 HashMap的成员变量 table</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 如果之前的数组有值，会对之前数组上所有的数据进行重新的hash运算，之前的数据无论是在链表，红黑树、桶位。那么要么还是处于以前的位置，要么在以前的位置上加上之前数组的长度</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;  <span class="comment">//遍历所有桶位</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;  <span class="comment">//如果桶位的数据不为空</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>; <span class="comment">//将之前桶位的数据置空</span></span><br><span class="line">                    <span class="comment">// 如果当前桶位没有形成链表或者树</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//重新计算该桶位数据的位置，可能是以前的位置也可能在以前的位置 + 之前数组的长度</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//如果目前的节点是红黑树结构</span></span><br><span class="line">                        <span class="comment">// 将红黑树进行切分，防止到新的位置，新的位置有可能成为一个链表</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; </span><br><span class="line">                        <span class="comment">// 定义地位和高位，低为的意思是与之前的数组长度相与为0，</span></span><br><span class="line">                        <span class="comment">// 高位指的是与之前数组长度相与结果为 之前数组的长度</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;  <span class="comment">//获取到下一个节点，以便下一次循环</span></span><br><span class="line">                     <span class="comment">// 让当前节点的hash值与之前长度相与，结果只有两种情况，要么为0, 要么为之前数组的长度值</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 链表的末尾如果为空，表示首次循环</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e; <span class="comment">//首次循环第一个节点就是桶位上的节点，也就是整条链上的头节点</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e; <span class="comment">//如果不是首次循环，那就把当前遍历的节点设置为尾巴节点的下个节点</span></span><br><span class="line">                                loTail = e;  <span class="comment">//那么当前遍历的节点就是成了尾巴节点</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;  <span class="comment">//此时表示节点的hash值与老的容量相与得到的结果为老的容量值数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果低位的尾巴节点不为空，表示链上有数据，那么就让低位的链还是处于和以前桶相同的索引位置</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                         <span class="comment">//如果高位的尾巴节点不为空，表示链上有数据，那么就让高位的链还是处于和以前桶相同的索引位置 + 以前数组的长度</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>putVal()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Node是存放新设置的数据 key value, hash, next         </span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//如果是第一次put值，table是空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// n的值为16</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// (n-1) &amp; hash 肯定是落在数组的索引范围内的，取出当前值，可能为也可能不为空(可能会产生hash碰撞问题)； 如果相同的索引位置已经有值了，那么p就不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果当前位置没有值的话，也就是没有产生hash碰撞的问题，那么直接给当前位置赋予新的值</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 已经存在的值的hash码与新设置的值的hash如果相同并不能作为对象相同的唯一标准，所以还要去比较地址，判断两个对象是否相同，如果相同，就直接用新的value替换老的value.</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//判断是否为树节点，已经构成一棵树</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 在同一个操作的值有没有下一个节点，如果没有下一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将我们新传入的数据生成一个新的节点挂在当前节点下</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果为第八个节点，如果此时数组的长度是小于64会执行扩容，扩容的代码为treeifyBin()方法，会去判断当前表的长度是否小于64</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1s</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//判断对象是否和链上的对象为同一个对象，如果为同一个对象，循环结束，直接替换就的value值</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果e不为空</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获得老数据的value</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// absent(缺席)</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 新值替换旧的值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 每一次添加数据，不仅仅是桶上的数据，也有链或者树上的节点，都会去判断有没有超过阈值，如果超过阈值就会重新去计算长度</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>treeify()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">    * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="comment">// 当数组的长度小于64的时候，并且链上的数据大于8的时候，会执行扩容；如果说链上的数据大于8，但是，数组的长度大于64，那么会直接转红黑树。</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
