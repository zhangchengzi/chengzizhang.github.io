<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ConcurrentHashMap底层源码分析</title>
    <url>/2020/02/28/ConcurrentHashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>ConcurrentHashMap是Java中的一个<strong>线程安全且高效的HashMap实现</strong>。平时涉及高并发如果要用map结构，那第一时间想到的就是它。<br>为什么它是线程安全的，我抽时间去看了下源码，关键在   <strong>synchronized</strong> 方法。这篇笔记写下我对源码的一些分析和理解，方便加深映像</p>
<a id="more"></a>

<p><strong>put 方法 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">//如果是第一次,则先创建哈希表</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//如果当前数据要放的位置上面没有数据,</span></span><br><span class="line">          <span class="comment">//则通过 cas 比较交换,将原始的 null 替换为最新的值</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">                <span class="comment">//如果当前要插入的数组位置有数据的,</span></span><br><span class="line">                <span class="comment">//则锁定当前表头,注意：是没有锁定当前要插入的对应的key 的具体数据,</span></span><br><span class="line">                <span class="comment">//因为到现在位置还不知道这个位置后有没有我们要放的数据,</span></span><br><span class="line">                <span class="comment">//有可能有,有可能没有,如果锁的是存在的那个节点,</span></span><br><span class="line">                <span class="comment">//得先进去遍历,但是有可能没有,那么可能到最后都没有加锁,就是去了安全性的意义</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap底层源码分析</title>
    <url>/2020/02/27/HashMap%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><ol>
<li>源码中属性介绍</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表数组的默认长度 16</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表数组的最大长度,2的30次方的原因是,int 最大值是 2的31次方减 1,所以只能是 30 次方</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//默认的加载因子,加载因子指的是 hashmap 中数据个数超过数组长度*当前加载因子的时候会触发扩容</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//当单个位置的数据链表长度超过 8 的时候会将该链表转换为红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当当前位置的红黑树内容长度小于 6 的时候会重新变回链表</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//当某个位置的链表在转换为红黑树的时候,如果此时数组长度小于 64 会先进行扩容</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="2-put-方法介绍"><a href="#2-put-方法介绍" class="headerlink" title="2 put 方法介绍"></a>2 put 方法介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//声明了一个局部变量 tab,局部变量 Node 类型的数据 p,int 类型 n,i</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">//首先将当前 hashmap 中的 table(哈希表)赋值给当前的局部变量 tab,然后判断tab 是不是空或者长度是不是 0,实际上就是判断当前 hashmap 中的哈希表是不是空或者长度等于 0</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//如果是空的或者长度等于0,代表现在还没哈希表,所以需要创建新的哈希表,默认就是创建了一个长度为 16 的哈希表</span></span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">//将当前哈希表中与要插入的数据位置对应的数据取出来,(n - 1) &amp; hash])就是找当前要插入的数据应该在哈希表中的位置,如果没找到,代表哈希表中当前的位置是空的,否则就代表找到数据了, 并赋值给变量 p</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//创建一个新的数据,这个数据没有下一条,并将数据放到当前这个位置</span></span><br><span class="line">      <span class="keyword">else</span> &#123;<span class="comment">//代表要插入的数据所在的位置是有内容的</span></span><br><span class="line">      <span class="comment">//声明了一个节点 e, 一个 key k</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp; <span class="comment">//如果当前位置上的那个数据的 hash 和我们要插入的 hash 是一样,代表没有放错位置</span></span><br><span class="line">          <span class="comment">//如果当前这个数据的 key 和我们要放的 key 是一样的,实际操作应该是就替换值</span></span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="comment">//将当前的节点赋值给局部变量 e</span></span><br><span class="line">              e = p;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果当前节点的 key 和要插入的 key 不一样,然后要判断当前节点是不是一个红黑色类型的节点</span></span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);<span class="comment">//如果是就创建一个新的树节点,并把数据放进去</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果不是树节点,代表当前是一个链表,那么就遍历链表</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;<span class="comment">//如果当前节点的下一个是空的,就代表没有后面的数据了</span></span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);<span class="comment">//创建一个新的节点数据并放到当前遍历的节点的后面</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 重新计算当前链表的长度是不是超出了限制</span></span><br><span class="line">                          treeifyBin(tab, hash);<span class="comment">//超出了之后就将当前链表转换为树,注意转换树的时候,如果当前数组的长度小于MIN_TREEIFY_CAPACITY(默认 64),会触发扩容,我个人感觉可能是因为觉得一个节点下面的数据都超过8 了,说明 hash寻址重复的厉害(比如数组长度为 16 ,hash 值刚好是 0或者 16 的倍数,导致都去同一个位置),需要重新扩容重新 hash</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//如果当前遍历到的数据和要插入的数据的 key 是一样,和上面之前的一样,赋值给变量 e,下面替换内容</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">//如果当前的节点不等于空,</span></span><br><span class="line">              V oldValue = e.value;<span class="comment">//将当前节点的值赋值给 oldvalue</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value; <span class="comment">//将当前要插入的 value 替换当前的节点里面值</span></span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++modCount;<span class="comment">//增加长度</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();<span class="comment">//如果当前的 hash表的长度已经超过了当前 hash 需要扩容的长度, 重新扩容,条件是 haspmap 中存放的数据超过了临界值(经过测试),而不是数组中被使用的下标</span></span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-扩容方法"><a href="#3-扩容方法" class="headerlink" title="3 扩容方法"></a>3 扩容方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//haspmap 触发扩容的条件有两个,一个是当存放的数据超过临界值的时候会触发扩容,</span></span><br><span class="line"><span class="comment">//另外一个是当需要转成红黑树的时候,如果当前数组的长度小于 64,会触发扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//声明了一个 oldtab ,并且把当前(扩容前) hashmap里面的哈希表赋值过来,如果是第一次放数据,此时这两个其实都是空</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//获取当前(扩容前)哈希表的长度,如果是第一次的话,就是 0,否则就是扩容之前的哈希表的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//当前(扩容前)哈希表需要扩容时候的长度,其实这值就是哈希表的长度*加载因子的长度,如果是第一次放数据,就是 0</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">//新的长度和新的扩容长度</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//如果是第一次的时候,这个长度是 0,所以不符合当前判断,如果大于 0 代表是原先的老哈希表长度已经超出限制了</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//看看最新的长度是不是大于等于hashmap 对数组长度的最大限制</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;<span class="comment">//设置为默认的最大长度</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; </span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">//如果没有超出长度限制,新的数组长度等于老的数组长度*2(向左移动 1 位)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//如果当前的扩容长度大于 0,代表已经有哈希表</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//代表还没有哈希表,实际上就是第一次向 map 中放数据</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新的哈希表长度为当前map 的默认值</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">//新的扩容长度为默认长度*默认的加载因子,这里算它的原因是为了不在后面放数据的时候每次都重新计算,因为每次都要算是不是应该扩容,如果不找变量接收,每次都要做数学运算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//如果新的长度还是 0,则继续计算</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;<span class="comment">//当前 hashma的扩容长度等于最新计算出来的扩容长度</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">//根据最新的长度创建对应长度的哈希表,如果是首次创建,默认就是 16</span></span><br><span class="line">        table = newTab;<span class="comment">//将当前 hashmap 中的哈希表赋值为最新刚刚创建的哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//如果原老的哈希表有数据,需要将老的数据放到新的哈希表,如果是首次创建就不执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">//遍历老的数组</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">//取出当前遍历的位置上的第一个节点</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果当前节点没有后面的数据</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//新的数组的最新的节点上的数据直接就是这个数据</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是不是树节点,如果是 就重新对树进行分割,然后放到新的位置</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// 创建两个链表,主要是因为基本上扩容的时候,部分数据会在原始位置,另外一部分数据会去向后便宜老数组的长度,比如原先是数组长度是 16,原先在 1 位置上面的数据,扩容到 32 后要么就还在 1,要么就应该去17,也就是向后移动原始长度(或者是扩容增加的长度)</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next; <span class="comment">//首先将当前的下一个数据赋值给 e</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//符合应该在原始位置条件的创建一条链表</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">//如果没有数据</span></span><br><span class="line">                                    loHead = e;<span class="comment">//当前节点就是一个头</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;<span class="comment">//否则当前的尾节点下一条数据就是 e</span></span><br><span class="line">                                loTail = e;<span class="comment">//e 就成为了尾结点</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;<span class="comment">//代表不符合原始位置的条件,就创建另外一个链表,来存放另外一部分数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)<span class="comment">//如果没有数据</span></span><br><span class="line">                                    hiHead = e;<span class="comment">//当前节点就是一个头</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;<span class="comment">//否则当前的尾节点下一条数据就是 e</span></span><br><span class="line">                                hiTail = e;<span class="comment">//e 就成为了尾结点</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//如果当前位置下一个数据不等于空,继续向下找</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; </span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;<span class="comment">//遍历完成后,当前位置的数据为上面构建的应该在当前原始位置的链表数据</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;<span class="comment">//将另外一部分数据直接放到后面的位置,位置为原始位置加上偏移量(因为扩容就是翻倍长度,所以偏移量就是原始的长度或者说是扩容增加的长度)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab; <span class="comment">//返回最新创建的那个哈希表</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-链表转红黑树"><a href="#4-链表转红黑树" class="headerlink" title="4 链表转红黑树"></a>4 链表转红黑树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">   * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果当前哈希表是空的或者是哈希表的数组长度小于 64,则触发扩容,这也是 hashmap 扩容的第二个条件和方式</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">          resize();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                  hd = p;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  p.prev = tl;</span><br><span class="line">                  tl.next = p;</span><br><span class="line">              &#125;</span><br><span class="line">              tl = p;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">              hd.treeify(tab);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap简述</title>
    <url>/2020/03/17/HashMap%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>底层是基于哈希表实现的键值对存储，继承AbstractMap并实现了Map接口，HashMap基于hashing原理，通过put() 和 get()方法存储和获取对象。<br>当我们将键值对传递给put()方法时，它调用键值对象hashCode()方法来计算hashCode，然后找到bucket（桶）位置来存储值对象。当获取对象时，通过健对象的equals()方法找到正确的键值对，然后返回值对象。</p>
<p>HashMap 使用LinkedList来解决碰撞问题。当发生碰撞，对象将会存储在LinkedList的下一个节点中。</p>
<p><strong>简单介绍一下hashcode()？</strong><br>hashcode就是通过hash函数计算得来的值，返回的是int类型</p>
  <a id="more"></a>

<p><strong>当两个不同键对象的hashCode相同时会发生什么？</strong></p>
<p>他们会存储在同一个bucket（散列桶）位置的LinkedList中。键对象的equals()方法用来找到键值对。</p>
<p><strong>nitialCapacity</strong>： 初始容量。指的是HashMap 集合初始化的时候自身的容量。可以在构造方法中指定。如果不指定的话，总容量默认值是16 .需要注意的是初始容量必须是2的幂次方</p>
<p><strong>size</strong> ： 当前HashMap中已经存储着的键值对数量 </p>
<p><strong>loadFactor</strong>: 加载因子。所谓的加载因子就是HashMap(当前的容量/总容量)达到一定值的时候，HashMap 会实施扩容。加载因子也可以通过构造方法中指定，默认的值是 0.75  .</p>
<p><strong>threshold</strong> ： 扩容阈值，即 扩容阈值 = HashMap 总容量  *  加载因子。 当前HashMap的容量大于或等于扩容阈值的时候就回去执行扩容。扩容的容量为当前HashMap 总容量的两倍。比如，当前 HashMap 的总容量 为 16  ，那么扩容之后为32.</p>
<p>举个例子：<br>          假设有一个HashMap 集合初始容量为<strong>16  ，</strong>那么扩容的阈值就是 0.75 * 16 = 12 . 也就是说，在你打算存入第13个值的时候，HashMap 会先执行扩容。</p>
<p><strong>Java JDK 1.7之前</strong>  HashMap 的实现方式是 Entry 数组+ 链表的形式。<strong>java 1.7 会在链表头插入（头插法）</strong>，使用头插法会造成一个问题，是当它在resize的时候，也就是说hashmap的扩容的过程，它的里面有一个 resize（）方法，然后它又调用了一个   transfer（） 方法，把里面的Entry进行一个rehash，在这个过程中可能会造成一个链表的循环（环形链表的问题），就有可能我在进行下一个get（）的时候造成一个死循环，因为它是没有加锁的，在多个线程并发的情况下，它不能对它的数据保证安全，就是我push（）进去的值，取出来还是我push（）进去的一个值，这是一个非常不安全的情况。<br><strong>Java JDK1.8之后</strong> <strong>1.8 之后它会在链表尾插入（尾插法）</strong>还有一个对它的一个非常大的变化就是 数据结构发生了改变，Entry节点 被 Node节点给替代了 它是一个 <strong>数组+链表+红黑树</strong>的一个数据结构。 <strong>1.8之后对 put（k,v）的过程也做了一个优化</strong>，首先对key的hashcode（）做hash 算法计算，然后是return 到 putval（）方法中进行的，它首先先判断tab是否为null，为null就创建，再一个计算index，并对null做处理，然后判断节点key是否存在，如果不为null,也就是节点key存在，直接覆盖value，否则判断该链为红黑树，然后判断链表长度是否大于8，进行一个红黑树转换的处理，最后一个步骤是判断是否超过最大容量也就是扩容。</p>
<p><strong>JDK1.8 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">7</span>                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>         n = (tab = resize()).length;</span><br><span class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理</span></span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">20</span>             e = p;</span><br><span class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st </span></span><br><span class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</span><br><span class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span>                 &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">35</span>                            <span class="keyword">break</span>;</span><br><span class="line"><span class="number">36</span>                 p = e;</span><br><span class="line"><span class="number">37</span>             &#125;</span><br><span class="line"><span class="number">38</span>         &#125;</span><br><span class="line"><span class="number">39</span>        </span><br><span class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">41</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">43</span>                 e.value = value;</span><br><span class="line"><span class="number">44</span>             afterNodeAccess(e);</span><br><span class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">46</span>         &#125;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"><span class="number">48</span>     ++modCount;</span><br><span class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">51</span>         resize();</span><br><span class="line"><span class="number">52</span>     afterNodeInsertion(evict);</span><br><span class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">54</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK 1.7 源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123; <span class="comment">//空表table的话，根据size的阈值填充</span></span><br><span class="line"><span class="number">3</span>       inflateTable(threshold);</span><br><span class="line"><span class="number">4</span>    &#125;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">6</span>        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"><span class="number">7</span>    <span class="keyword">int</span> hash = hash(key);<span class="comment">//成hash，得到索引Index的映射</span></span><br><span class="line"><span class="number">8</span>    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"><span class="number">9</span>    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//遍历当前索引的冲突链，找是否存在对应的key</span></span><br><span class="line"><span class="number">10</span>       Object k;</span><br><span class="line"><span class="number">11</span>        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<span class="comment">//如果存在对应的key， 则替换oldValue并返回oldValue</span></span><br><span class="line"><span class="number">12</span>            V oldValue = e.value;</span><br><span class="line"><span class="number">13</span>            e.value = value;</span><br><span class="line"><span class="number">14</span>            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">15</span>            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">16</span>        &#125;</span><br><span class="line"><span class="number">17</span>    &#125;</span><br><span class="line"><span class="number">18</span>    <span class="comment">//冲突链中不存在新写入的Entry的key</span></span><br><span class="line"><span class="number">19</span>    modCount++;</span><br><span class="line"><span class="number">20</span>    addEntry(hash, key, value, i);</span><br><span class="line"><span class="number">21</span>    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是Hash碰撞？</strong></p>
<p>所谓哈希碰撞，就是不同节点值（key-value键值对）的key值算出相同的下标值，就是有可能两个不同的原始值在经过hash算法运算后得到同样的结果，这样就是哈希碰撞</p>
<p><strong>如何解决Hash碰撞的？</strong></p>
<p>为解决哈希碰撞，hashmap采用链地址法解决哈希冲突，也就是采用链表解决哈希冲突，<br>但只单用链表解决哈希冲突的话，链表太长会导致操作hashmap的效率值下降得太多，<br>所以在jdk1.8之后，又引入了红黑树来解决哈希冲突，环形链表问题。</p>
<p><strong>有几种方法？</strong></p>
<p><strong>开放定址法</strong>：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。<br><strong>链地址法</strong>：链地址法其实就是HashMap中用的策略<br>HashMap 使用LinkedList来解决碰撞问题。当发生碰撞，对象将会存储在LinkedList的下一个节点中。）<br>原理是在HashMap中同样哈希值的位置以一串链表存储起来数据，把多个原始值不同而哈希结果相同的数据以链表存储起来。</p>
<p><strong>红黑怎么解决了冲突？ 为什么超过8就转红黑树？</strong></p>
<p><strong>通过自旋</strong></p>
<p>首先呢，你要清楚hashmap其实就是一个数组（entry类型的数组）。<br>理想的哈希表，是尽可能让节点分散到数组的各个下标位置上，而又不重复（没有哈希冲突）。<br>这样呢，才是最理想的hashmap，时间复杂度是O（1）。<br>但是呢，没有一个哈希算法可以避免哈希冲突，冲突再所难免，所以有冲突呢，就得想办法解决。<br>而链表跟红黑树其实只是解决哈希冲突的一个方式而已</p>
<p>因为只单单链表解决哈希冲突的话，当长度超过8时，效率明显不及用红黑树解决哈希冲突</p>
<p>8就是一个链表跟红黑树解决哈希冲突效率对比的临界点</p>
<p><strong>当key相同时会发生什么 key不同呢？</strong></p>
<p>不会有相同的key，其hashCode一定一样，那么put时回去同一桶链表中寻找，而在源码中put的时候<br>如果key和hashCode都与之前存在的节点一样，那么会用新的value覆盖旧的value,并且put方法返回新value的值。</p>
<p><strong>hashmap是线程安全的吗？还有什么线程安全map（类）</strong></p>
<p>因为 hashmap 的 key可以为null值，当发生并发问题时，会出现两个问题：  1）、链表可能会形成环形  2）、发生数据覆盖问题    当一个线程进来的时候，开始判断索引值，    如果索引值为空，当它开始new对象时，代码还没来得及执行，    第二个线程进来，会直接判断为null，会把之前的数据给覆盖掉，发生数据覆盖问题</p>
<p><strong>线程安全map</strong>:  HashTable  SynchronizedMap <strong>ConcurrentHashMap - 推荐</strong>（并发高）</p>
<p><strong>为什么同样是线程安全的不用HashTable 而使用 ConcurrentHashMap ？</strong></p>
<p>因为它的并发度是更高的，普通的 HashTable 保证线程安全的策略是直接对里面的方法进行一个 Synchronized就是加了一个同步锁，而ConcurrentHashMap 的数据结构在1.8之后同样的是 数组+链表+红黑树 它在执行Synchronized上锁的一个过程它只锁住我目前获取到的那个Entry 所在的那个节点的一个值，而且它上锁是使用了  CAS + Synchronized,再加上JDK 1.6之后对Synchronized的一个优化锁升级的过程，它的执行效率，并发是更高的。</p>
<p><strong>PS</strong>:上面这段话如果不理解的话，别着急，我下面还写了一段关于线程安全的HashMap的描述，或者可以看看我之前写的两篇源码分析的文章</p>
<p><strong>什么是锁升级？锁升级的一个过程是什么？</strong></p>
<p>最开始的时候它是一个无锁的状态，当一个线程上来它会去先判断一下是否上了锁，然后再升级，这个锁是支持偏向锁的，就是当前我获取到的锁资源的这个线程，我会优先让他再去获取到这个锁，如果它没有获取到这个锁，就升级成一个轻量级的，一个CAS的锁就是一个乐观锁，乐观锁的时候它是一个比较有交换的过程，如果这个CAS连续没有设置成功的话，它会进行一个自旋，然后自旋到一定的次数之后会升级成一个Synchronized一个重量级的锁，这样的话就保证了它的一个性能的问题</p>
<p><strong>Hashmap是线程安全的吗？如何将它变为线程安全的？</strong></p>
<p><strong>Hashmap</strong>对应的线程安全类有 <strong>Hashtable</strong>、有<strong>ConcurrentHashmap</strong>，也可以通过<strong>Collections</strong>工具类 通过  Collections.Synchronized  将Hashmap包装成线程安全版的map。如果要在三个做出选择，还是建议使用ConcurrentHashMap，因为ConcurrentHashMap的锁粒度要更小，效率要更高。<br>虽然这三者都有通过Synchronized同步锁实现的线程安全。<br>但是这其中，Hashtable的效率跟通过Collections工具类包装的map的效率基本无异，这两者的锁粒度一样，差别只是Hashtable锁的是对象本身，而通过Collections工具类包装的map锁的是同一个Object对象，进入方法后就是一段加了Synchronized同步锁的代码段。两者锁粒度是一样的，效率实际也都没多大区别。<br>而ConcurrentHashMap在JDK1.8版本的时，它加锁的机制是怎样的？它是先根据待插入的节点对象的key值算出节点对象该该放在数组（ConcurrentHashmap底层就是数组）的哪个下标位置上，在看看这个下标位置是否为空，为空则通过CAS机制（乐观锁）来插入节点对象。而如果下标位置不为空，那么ConcurrentHashMap会以Synchronized同步锁来加锁，加锁的对象是数组下标位置上的头节点对象，这样呢，<strong>锁的粒度就小很多，出现并发的概率也会小很多</strong>，自然效率要比前两者高很多。<br>就是说Hashtable及Collections包装的map加锁是锁整一段数组，而ConcurrentHashmap会先在下标位置空的时候通过CAS机制（乐观锁）插入节点数据，此种方式其实是没加锁，而当下标位置不为空时，就是这个下标位置是有数据的，它才会加锁到具体的下标的一个位置。</p>
<p><strong>哈希表  数组  链表的区别。</strong></p>
<p>程序中，存放指定的数据最常用的数据结构有两种：数组和链表。</p>
<p><strong>数组和链表的区别：</strong></p>
<p>1，数组是将元素在内存中连续存放（顺序存储）。<br>   链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。</p>
<p>2，数组必须事先定义固定的长度，不能适应数据动态的增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；<br>   链表动态地进行存储分配，可以适应数据变化动态地增减。</p>
<p>3，（静态）数组从栈中分配空间，对于程序方便快速，但是自由度小；<br>    链表从堆中分配空间，自由度大但是申请管理比较麻烦。</p>
<p> <strong>数组和链表在存储数据方面到底谁好？根据数组和链表的特性，分两种情况讨论：</strong></p>
<p>1，当进行数据查询时，数组可以直接通过下标迅速访问数组中的元素。<br>   而链表则需要从第一个元素开始一直找到需要的元素位置，显然，数组的查询效率会比链表的高。</p>
<p>2，当进行增加或删除元素时，在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，<br>然后将要增加的元素放在其中。同样，如果想删除一个元素，需要移动大量去填掉被移动的元素，<br>而链表只需改动元素中的指针即可实现增加或删除元素。</p>
<p><strong>那么哈希表，是既能具备数组的快速查询的优点，又能融合链表方便快捷的增加删除元素的优势。</strong></p>
<p>所谓的hash,简单的说就是散列，即将输入的数据通过hash函数得到一个key值，输入的数据存储到数组中下标的key值的数组单元中去。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
